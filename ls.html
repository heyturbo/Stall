<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿·ä½ ç‚‰çŸ³ä¼ è¯´</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
        }
        body {
            background-color: #2c3e50;
            color: white;
            padding: 10px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%232c3e50"/><path d="M0 0L100 100M100 0L0 100" stroke="%23375a7f" stroke-width="1"/></svg>');
            background-size: 50px;
        }
        #game-container {
            max-width: 800px;
            margin: 0 auto;
            background-color: rgba(52, 73, 94, 0.9);
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 2px solid #f39c12;
        }
        .game-header {
            text-align: center;
            margin-bottom: 15px;
            position: relative;
        }
        .game-header h1 {
            font-size: 32px;
            color: #f39c12;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            font-family: 'Trajan Pro', serif;
            letter-spacing: 1px;
            background: linear-gradient(to right, #e67e22, #f1c40f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .turn-indicator {
            position: absolute;
            right: 10px;
            top: 10px;
            background-color: #3498db;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        .turn-indicator.enemy-turn {
            background-color: #e74c3c;
        }
        .game-board {
            display: flex;
            flex-direction: column;
            gap: 20px;
            position: relative;
        }
        .player-area, .opponent-area {
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: relative;
        }
        .board-divider {
            height: 30px;
            background: linear-gradient(to right, transparent, #f39c12, transparent);
            border-radius: 5px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .board-divider:before {
            content: "âš”";
            font-size: 20px;
            color: white;
            text-shadow: 0 0 5px #e74c3c;
        }
        .info-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #2c3e50;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #3498db;
            transition: box-shadow 0.3s;
        }
        .current-turn .info-bar {
            box-shadow: 0 0 10px #f39c12;
        }
        .hero {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .hero-portrait {
            width: 60px;
            height: 60px;
            background-color: #3498db;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s;
        }
        .hero-portrait.player {
            background: radial-gradient(circle, #3498db, #2980b9);
        }
        .hero-portrait.opponent {
            background: radial-gradient(circle, #e74c3c, #c0392b);
        }
        .hero-portrait:hover {
            transform: scale(1.05);
        }
        .hero-portrait:before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            transform: skewX(-30deg);
            transition: 0.5s;
        }
        .hero-portrait:hover:before {
            left: 100%;
        }
        .hero-armor {
            position: absolute;
            bottom: 0;
            right: 0;
            background-color: #95a5a6;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            font-weight: bold;
            border: 1px solid white;
        }
        .hero-stats {
            display: flex;
            flex-direction: column;
        }
        .mana, .health {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .mana-crystal, .health-icon {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
        }
        .mana-crystal {
            background: radial-gradient(circle, #3498db, #2980b9);
            box-shadow: 0 0 5px #3498db;
        }
        .health-icon {
            background: radial-gradient(circle, #e74c3c, #c0392b);
            box-shadow: 0 0 5px #e74c3c;
        }
        .mana span, .health span {
            font-weight: bold;
        }
        .mana {
            color: #3498db;
        }
        .health {
            color: #e74c3c;
        }
        .deck-count {
            background-color: #2c3e50;
            border: 1px solid #95a5a6;
            border-radius: 5px;
            padding: 5px;
            text-align: center;
            font-size: 12px;
            width: 60px;
            height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
        }
        .deck-count:before {
            content: "";
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            background-image: repeating-linear-gradient(
                -45deg,
                #34495e,
                #34495e 5px,
                #2c3e50 5px,
                #2c3e50 10px
            );
            z-index: -1;
            border-radius: 3px;
        }
        .deck-count span {
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 2px black;
        }
        .minions-area {
            min-height: 100px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            padding: 10px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            transition: background-color 0.3s;
            border: 1px dashed rgba(255, 255, 255, 0.2);
        }
        .current-turn .minions-area {
            background-color: rgba(52, 152, 219, 0.1);
            border-color: rgba(52, 152, 219, 0.5);
        }
        .hand {
            display: flex;
            justify-content: center;
            gap: 5px;
            flex-wrap: wrap;
            padding: 10px 0;
            min-height: 120px;
            position: relative;
        }
        .hand.opponent-hand {
            min-height: 60px;
        }
        .card {
            width: 70px;
            height: 100px;
            background: linear-gradient(145deg, #f39c12, #e67e22);
            border-radius: 5px;
            cursor: pointer;
            position: relative;
            padding: 5px;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            transition: all 0.2s ease;
            transform-origin: center bottom;
            border: 1px solid #d35400;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }
        .player-hand .card {
            transform: translateY(0) rotate(0deg);
        }
        .player-hand .card:hover {
            transform: translateY(-20px) scale(1.2);
            z-index: 10;
        }
        .player-hand .card:not(:hover) {
            margin-right: -10px;
        }
        .player-hand .card:nth-child(2n) {
            transform: rotate(2deg);
        }
        .player-hand .card:nth-child(2n+1) {
            transform: rotate(-2deg);
        }
        .opponent-hand .card {
            background: linear-gradient(145deg, #3498db, #2980b9);
            transform: translateY(15px) scale(0.9);
            margin-left: -30px;
            height: 90px;
        }
        .opponent-hand .card-back {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="70" height="100" viewBox="0 0 70 100"><rect width="70" height="100" fill="%232980b9"/><circle cx="35" cy="50" r="20" fill="%233498db"/><path d="M 25 40 L 45 60 M 45 40 L 25 60" stroke="%23ecf0f1" stroke-width="2"/></svg>');
            background-size: cover;
        }
        .card-glare {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 50%);
            border-radius: 5px;
            pointer-events: none;
        }
        .card-name {
            font-weight: bold;
            text-align: center;
            margin-bottom: 3px;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .card-description {
            font-size: 8px;
            flex-grow: 1;
            overflow-wrap: break-word;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
            padding: 2px;
            color: #fff;
            text-shadow: 0 0 1px black;
            overflow: hidden;
            max-height: 50px;
        }
        .card-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 3px;
        }
        .card-cost {
            color: white;
            font-weight: bold;
            position: absolute;
            top: 2px;
            left: 2px;
            background: radial-gradient(circle, #3498db, #2980b9);
            width: 15px;
            height: 15px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            text-shadow: 0 0 1px black;
        }
        .card-rarity {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 5px;
            height: 5px;
            border-radius: 50%;
        }
        .rarity-common {
            background-color: #95a5a6;
        }
        .rarity-rare {
            background-color: #3498db;
        }
        .rarity-epic {
            background-color: #9b59b6;
        }
        .rarity-legendary {
            background-color: #f1c40f;
        }
        .card-attack {
            color: #f1c40f;
            font-weight: bold;
            text-shadow: 0 0 2px black;
        }
        .card-health {
            color: #e74c3c;
            font-weight: bold;
            text-shadow: 0 0 2px black;
        }
        .card-durability {
            color: #95a5a6;
            font-weight: bold;
            text-shadow: 0 0 2px black;
        }
        .card-type-icon {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 15px;
            height: 15px;
            font-size: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.3);
        }
        .playable {
            box-shadow: 0 0 10px #2ecc71;
            border-color: #2ecc71;
        }
        .not-playable {
            filter: brightness(0.7);
        }
        .minion {
            width: 60px;
            height: 80px;
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            border-radius: 5px;
            position: relative;
            padding: 5px;
            font-size: 10px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s;
            border: 1px solid #7d3c98;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }
        .minion:hover {
            transform: scale(1.1);
            z-index: 5;
        }
        .minion.can-attack {
            box-shadow: 0 0 10px #2ecc71;
            animation: pulse 1.5s infinite;
        }
        .minion.exhausted {
            filter: brightness(0.7);
        }
        .minion-name {
            font-weight: bold;
            text-align: center;
            font-size: 9px;
            margin-bottom: 2px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .minion-stats {
            display: flex;
            justify-content: space-between;
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
        }
        .minion-attack {
            color: #f1c40f;
            font-weight: bold;
            text-shadow: 0 0 2px black;
            background: radial-gradient(circle, rgba(241, 196, 15, 0.3), transparent);
            width: 15px;
            height: 15px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .minion-health {
            color: #e74c3c;
            font-weight: bold;
            text-shadow: 0 0 2px black;
            background: radial-gradient(circle, rgba(231, 76, 60, 0.3), transparent);
            width: 15px;
            height: 15px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .minion-effects {
            display: flex;
            justify-content: center;
            gap: 2px;
            font-size: 8px;
            position: absolute;
            top: 20px;
            width: 100%;
            left: 0;
        }
        .effect {
            padding: 1px 3px;
            border-radius: 3px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
        }
        .taunt {
            border: 2px solid #f1c40f;
            animation: taunt-glow 2s infinite;
        }
        .divine-shield {
            position: relative;
        }
        .divine-shield:after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 7px;
            background: rgba(241, 196, 15, 0.2);
            box-shadow: 0 0 10px #f1c40f;
            z-index: -1;
            animation: shield-pulse 2s infinite;
        }
        .poisonous {
            border: 2px solid #2ecc71;
        }
        .poisonous:after {
            content: 'â˜ ';
            position: absolute;
            top: 2px;
            right: 2px;
            color: #2ecc71;
            font-size: 10px;
        }
        .damaged .minion-health {
            color: #ff0000;
            animation: damaged-pulse 1s infinite;
        }
        .buffed .minion-attack {
            color: #2ecc71;
            animation: buffed-pulse 1s infinite;
        }
        .sleeping {
            position: relative;
        }
        .sleeping:after {
            content: "Z";
            position: absolute;
            top: 10px;
            right: 5px;
            font-size: 12px;
            font-weight: bold;
            color: #3498db;
            animation: sleeping 2s infinite;
        }
        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .btn {
            padding: 8px 15px;
            background: linear-gradient(to bottom, #3498db, #2980b9);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 3px 0 #1c6391, 0 4px 6px rgba(0, 0, 0, 0.3);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }
        .btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
        }
        .btn:hover:before {
            left: 100%;
        }
        .btn:hover {
            background: linear-gradient(to bottom, #2980b9, #2573a7);
            transform: translateY(1px);
            box-shadow: 0 2px 0 #1c6391, 0 3px 6px rgba(0, 0, 0, 0.3);
        }
        .btn:active {
            transform: translateY(3px);
            box-shadow: 0 0 0 #1c6391, 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        .btn:disabled {
            background: linear-gradient(to bottom, #95a5a6, #7f8c8d);
            cursor: not-allowed;
            box-shadow: 0 3px 0 #6a7778, 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .end-turn-btn {
            background: linear-gradient(to bottom, #2ecc71, #27ae60);
            box-shadow: 0 3px 0 #1b7943, 0 4px 6px rgba(0, 0, 0, 0.3);
            min-width: 120px;
        }
        .end-turn-btn:hover {
            background: linear-gradient(to bottom, #27ae60, #219651);
            box-shadow: 0 2px 0 #1b7943, 0 3px 6px rgba(0, 0, 0, 0.3);
        }
        .end-turn-btn:active {
            box-shadow: 0 0 0 #1b7943, 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        .enemy-turn .end-turn-btn {
            animation: enemy-turn-btn 2s infinite;
        }
        .log-container {
            margin-top: 10px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 10px;
            max-height: 100px;
            overflow-y: auto;
            border: 1px solid #34495e;
            scrollbar-width: thin;
            scrollbar-color: #3498db #2c3e50;
        }
        .log-container::-webkit-scrollbar {
            width: 8px;
        }
        .log-container::-webkit-scrollbar-track {
            background: #2c3e50;
        }
        .log-container::-webkit-scrollbar-thumb {
            background-color: #3498db;
            border-radius: 4px;
        }
        .log-message {
            margin-bottom: 5px;
            font-size: 12px;
            border-left: 3px solid transparent;
            padding-left: 5px;
            transition: all 0.3s;
        }
        .log-message.player {
            border-left-color: #3498db;
        }
        .log-message.opponent {
            border-left-color: #e74c3c;
        }
        .log-message.system {
            border-left-color: #f1c40f;
        }
        .log-message.damage {
            color: #e74c3c;
        }
        .log-message.heal {
            color: #2ecc71;
        }
        .log-message:last-child {
            font-weight: bold;
        }
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
            perspective: 1000px;
        }
        .game-over-content {
            background-color: #34495e;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 2px solid #f39c12;
            transform: rotateX(20deg);
            animation: game-over-bounce 1s ease-out forwards;
        }
        .game-over h2 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #f39c12;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }
        .restart-btn {
            padding: 15px 30px;
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
            transition: all 0.3s;
            box-shadow: 0 5px 0 #962d22, 0 6px 10px rgba(0, 0, 0, 0.3);
            margin-top: 20px;
        }
        .restart-btn:hover {
            background: linear-gradient(to bottom, #c0392b, #a73225);
            transform: translateY(2px);
            box-shadow: 0 3px 0 #962d22, 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #34495e;
            padding: 20px;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
            border: 2px solid #f39c12;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            animation: modal-appear 0.3s ease-out forwards;
        }
        .modal-content h3 {
            text-align: center;
            margin-bottom: 15px;
            color: #f39c12;
        }
        .target-selection {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }
        .target {
            width: 80px;
            height: 80px;
            background: linear-gradient(145deg, #3498db, #2980b9);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
            color: white;
            font-weight: bold;
            border: 1px solid #2573a7;
            font-size: 12px;
            position: relative;
            overflow: hidden;
        }
        .target:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
        }
        .target:hover:before {
            left: 100%;
        }
        .target:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px #3498db;
            z-index: 5;
        }
        .target.enemy {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border-color: #b83729;
        }
        .target.enemy:hover {
            box-shadow: 0 0 10px #e74c3c;
        }
        .card-being-played {
            animation: card-play 0.5s ease-out;
        }
        .damage-animation {
            animation: damage-shake 0.5s;
        }
        .heal-animation {
            animation: heal-pulse 0.5s;
        }
        .mana-crystal-container {
            display: flex;
            gap: 2px;
            margin-top: 5px;
            flex-wrap: wrap;
            max-width: 150px;
        }
        .crystal {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #95a5a6;
            transition: all 0.3s;
        }
        .crystal.filled {
            background: radial-gradient(circle, #3498db, #2980b9);
            box-shadow: 0 0 5px #3498db;
        }
        .crystal.temporary {
            background: radial-gradient(circle, #e67e22, #d35400);
            box-shadow: 0 0 5px #e67e22;
        }
        .weapon-container {
            display: flex;
            align-items: center;
            gap: 5px;
            position: absolute;
            bottom: -5px;
            left: -20px;
        }
        .weapon {
            width: 30px;
            height: 30px;
            background: linear-gradient(145deg, #e67e22, #d35400);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        .weapon-stats {
            position: absolute;
            width: 100%;
            bottom: -3px;
            display: flex;
            justify-content: space-between;
            font-size: 8px;
            padding: 0 2px;
        }
        .weapon-attack {
            color: #f1c40f;
            font-weight: bold;
            text-shadow: 0 0 2px black;
        }
        .weapon-durability {
            color: #95a5a6;
            font-weight: bold;
            text-shadow: 0 0 2px black;
        }
        .card-counter {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .fatigue-counter {
            color: #e74c3c;
            font-weight: bold;
            display: none;
        }
        .fatigue-counter.active {
            display: block;
            animation: fatigue-pulse 1s infinite;
        }

        /* åŠ¨ç”»æ•ˆæœ */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(46, 204, 113, 0); }
            100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); }
        }
        
        @keyframes taunt-glow {
            0% { box-shadow: 0 0 5px rgba(241, 196, 15, 0.7); }
            50% { box-shadow: 0 0 10px rgba(241, 196, 15, 0.9); }
            100% { box-shadow: 0 0 5px rgba(241, 196, 15, 0.7); }
        }
        
        @keyframes shield-pulse {
            0% { opacity: 0.3; }
            50% { opacity: 0.6; }
            100% { opacity: 0.3; }
        }
        
        @keyframes damaged-pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        @keyframes buffed-pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        @keyframes sleeping {
            0% { opacity: 0.3; transform: translateY(0); }
            50% { opacity: 1; transform: translateY(-5px); }
            100% { opacity: 0.3; transform: translateY(0); }
        }
        
        @keyframes enemy-turn-btn {
            0% { background: linear-gradient(to bottom, #e74c3c, #c0392b); }
            50% { background: linear-gradient(to bottom, #c0392b, #9e2f24); }
            100% { background: linear-gradient(to bottom, #e74c3c, #c0392b); }
        }
        
        @keyframes game-over-bounce {
            0% { transform: rotateX(90deg) translateY(-100px); opacity: 0; }
            70% { transform: rotateX(10deg) translateY(30px); opacity: 1; }
            100% { transform: rotateX(0deg) translateY(0); opacity: 1; }
        }
        
        @keyframes modal-appear {
            from { transform: scale(0.7); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        @keyframes card-play {
            0% { transform: translateY(-50px) scale(1.2); opacity: 0; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }
        
        @keyframes damage-shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-2px); }
            100% { transform: translateX(0); }
        }
        
        @keyframes heal-pulse {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
            100% { filter: brightness(1); }
        }
        
        @keyframes fatigue-pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 600px) {
            .hand {
                gap: 3px;
            }
            .card {
                width: 55px;
                height: 80px;
                font-size: 9px;
            }
            .card-description {
                font-size: 7px;
            }
            .minion {
                width: 50px;
                height: 70px;
            }
            .hero-portrait {
                width: 50px;
                height: 50px;
            }
            .btn {
                padding: 6px 10px;
                font-size: 12px;
            }
            .game-header h1 {
                font-size: 24px;
            }
            .turn-indicator {
                font-size: 10px;
                padding: 3px 6px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="game-header">
            <h1>è¿·ä½ ç‚‰çŸ³ä¼ è¯´</h1>
            <div class="turn-indicator" id="turn-indicator">ä½ çš„å›åˆ</div>
        </div>
        <div class="game-board">
            <div class="opponent-area" id="opponent-area">
                <div class="info-bar">
                    <div class="hero">
                        <div class="hero-portrait opponent" id="opponent-portrait">
                            æ•Œ
                            <div class="hero-armor" id="opponent-armor" style="display: none;">0</div>
                        </div>
                        <div class="hero-stats">
                            <div class="health"><div class="health-icon">â¤</div> <span id="opponent-health">30</span></div>
                            <div class="mana"><div class="mana-crystal">ğŸ’</div> <span id="opponent-mana">0</span>/<span id="opponent-max-mana">0</span></div>
                            <div class="mana-crystal-container" id="opponent-crystals"></div>
                        </div>
                    </div>
                    <div class="card-counter">
                        <div class="hand opponent-hand" id="opponent-hand"></div>
                        <div class="deck-count">
                            ç‰Œåº“<br>
                            <span id="opponent-deck-count">0</span>
                            <div class="fatigue-counter" id="opponent-fatigue">ç–²åŠ³: <span>0</span></div>
                        </div>
                    </div>
                </div>
                <div class="minions-area" id="opponent-minions"></div>
            </div>
            
            <div class="board-divider"></div>
            
            <div class="player-area" id="player-area">
                <div class="minions-area" id="player-minions"></div>
                <div class="info-bar">
                    <div class="hero">
                        <div class="hero-portrait player" id="player-portrait">
                            æˆ‘
                            <div class="hero-armor" id="player-armor" style="display: none;">0</div>
                            <div class="weapon-container" id="player-weapon-container" style="display: none;">
                                <div class="weapon" id="player-weapon">
                                    âš”
                                    <div class="weapon-stats">
                                        <div class="weapon-attack" id="weapon-attack">0</div>
                                        <div class="weapon-durability" id="weapon-durability">0</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="hero-stats">
                            <div class="health"><div class="health-icon">â¤</div> <span id="player-health">30</span></div>
                            <div class="mana"><div class="mana-crystal">ğŸ’</div> <span id="player-mana">0</span>/<span id="player-max-mana">0</span></div>
                            <div class="mana-crystal-container" id="player-crystals"></div>
                        </div>
                    </div>
                    <div class="card-counter">
                        <div class="action-buttons">
                            <button class="btn end-turn-btn" id="end-turn-btn">ç»“æŸå›åˆ</button>
                        </div>
                        <div class="deck-count">
                            ç‰Œåº“<br>
                            <span id="player-deck-count">0</span>
                            <div class="fatigue-counter" id="player-fatigue">ç–²åŠ³: <span>0</span></div>
                        </div>
                    </div>
                </div>
                <div class="hand player-hand" id="player-hand"></div>
            </div>
        </div>
        
        <div class="log-container" id="log-container"></div>
    </div>
    
    <div class="modal" id="target-modal">
        <div class="modal-content">
            <h3>é€‰æ‹©ç›®æ ‡</h3>
            <div class="target-selection" id="target-selection"></div>
        </div>
    </div>
    
    <div class="game-over" id="game-over" style="display: none;">
        <div class="game-over-content">
            <h2 id="winner-text">æ¸¸æˆç»“æŸ</h2>
            <button class="restart-btn" id="restart-btn">é‡æ–°å¼€å§‹</button>
        </div>
    </div>
    
    <script>
        // æ¸¸æˆçŠ¶æ€
        const gameState = {
            currentTurn: 'player',
            turnCount: 1,
            playerHealth: 30,
            playerMaxHealth: 30,
            playerArmor: 0,
            opponentHealth: 30,
            opponentMaxHealth: 30,
            opponentArmor: 0,
            playerMana: 1,
            playerMaxMana: 1,
            playerTempMana: 0,
            opponentMana: 1,
            opponentMaxMana: 1,
            opponentTempMana: 0,
            playerHand: [],
            opponentHand: [],
            playerMinions: [],
            opponentMinions: [],
            playerDeck: [],
            opponentDeck: [],
            playerGraveyard: [],
            opponentGraveyard: [],
            playerFatigueDamage: 0,
            opponentFatigueDamage: 0,
            playerWeapon: null,
            opponentWeapon: null,
            selectedCard: null,
            selectedMinion: null,
            targetCallback: null,
            spellInProgress: false,
            gameOver: false,
            animations: true,
            gameStarted: false
        };
        
        // å¡ç‰Œåº“å®šä¹‰ - å®Œå…¨å®ç°å„ç§æ•ˆæœ
        const cardLibrary = [
            // éšä»å¡ç‰Œ
            { 
                id: 1, 
                name: 'æŠ¤å«', 
                type: 'minion', 
                cost: 1, 
                attack: 1, 
                health: 2, 
                baseHealth: 2,
                description: 'å˜²è®½', 
                effects: ['taunt'],
                rarity: 'common' 
            },
            { 
                id: 2, 
                name: 'ä¾å„’å‘æ˜å®¶', 
                type: 'minion', 
                cost: 2, 
                attack: 1, 
                health: 1,
                baseHealth: 1, 
                description: 'æˆ˜å¼ï¼šæŠ½ä¸€å¼ ç‰Œ', 
                effects: [], 
                battlecry: 'draw',
                rarity: 'common' 
            },
            { 
                id: 3, 
                name: 'å›¢é˜Ÿé¢†è¢–', 
                type: 'minion', 
                cost: 3, 
                attack: 2, 
                health: 2,
                baseHealth: 2, 
                description: 'ä½ çš„å…¶ä»–éšä»è·å¾—+1æ”»å‡»åŠ›', 
                effects: ['aura'], 
                auraEffect: 'attack+1',
                rarity: 'rare' 
            },
            { 
                id: 4, 
                name: 'æš´é£åŸéª‘å£«', 
                type: 'minion', 
                cost: 4, 
                attack: 2, 
                health: 5,
                baseHealth: 5, 
                description: 'å˜²è®½', 
                effects: ['taunt'],
                rarity: 'common' 
            },
            { 
                id: 5, 
                name: 'å± é¾™è€…', 
                type: 'minion', 
                cost: 5, 
                attack: 5, 
                health: 2,
                baseHealth: 2, 
                description: 'æˆ˜å¼ï¼šå¯¹æ‰€æœ‰éšä»é€ æˆ1ç‚¹ä¼¤å®³', 
                effects: [], 
                battlecry: 'damage-all-minions',
                rarity: 'rare' 
            },
            { 
                id: 6, 
                name: 'ä½œæˆ˜å‚€å„¡', 
                type: 'minion', 
                cost: 2, 
                attack: 3, 
                health: 2,
                baseHealth: 2, 
                description: 'æ— æ³•æ”»å‡»è‹±é›„', 
                effects: ['cant-attack-hero'],
                rarity: 'common' 
            },
            { 
                id: 7, 
                name: 'å¤§ä¸»æ•™', 
                type: 'minion', 
                cost: 5, 
                attack: 3, 
                health: 7,
                baseHealth: 7, 
                description: 'æ¯å›åˆç»“æŸæ—¶å›å¤2ç‚¹ç”Ÿå‘½å€¼', 
                effects: ['endTurn'], 
                endTurnEffect: 'heal',
                rarity: 'epic' 
            },
            { 
                id: 8, 
                name: 'é“¶è‰²éª‘æ‰‹', 
                type: 'minion', 
                cost: 3, 
                attack: 2, 
                health: 3,
                baseHealth: 3, 
                description: 'åœ£ç›¾', 
                effects: ['divine-shield'],
                rarity: 'common' 
            },
            { 
                id: 9, 
                name: 'ç‹¼äºº', 
                type: 'minion', 
                cost: 4, 
                attack: 3, 
                health: 3,
                baseHealth: 3, 
                description: 'æˆ˜å¼ï¼šå¯¹æ‰€æœ‰æ•Œæ–¹éšä»é€ æˆ1ç‚¹ä¼¤å®³', 
                effects: [], 
                battlecry: 'damage-all-enemy-minions',
                rarity: 'rare' 
            },
            { 
                id: 10, 
                name: 'å¥¥æœ¯å­¦å¾’', 
                type: 'minion', 
                cost: 1, 
                attack: 1, 
                health: 1,
                baseHealth: 1, 
                description: 'æ³•æœ¯ä¼¤å®³+1', 
                effects: ['spell-damage'], 
                spellDamage: 1,
                rarity: 'common' 
            },
            { 
                id: 11, 
                name: 'é£Ÿäººé­”', 
                type: 'minion', 
                cost: 6, 
                attack: 6, 
                health: 7,
                baseHealth: 7, 
                description: 'å˜²è®½', 
                effects: ['taunt'],
                rarity: 'common' 
            },
            { 
                id: 12, 
                name: 'å±±å²­å·¨äºº', 
                type: 'minion', 
                cost: 10, 
                attack: 8, 
                health: 8,
                baseHealth: 8, 
                description: 'ä½ æ¯æœ‰ä¸€ç‚¹ç”Ÿå‘½å€¼å‡å°‘ï¼Œè¯¥ç‰Œçš„æ³•åŠ›å€¼æ¶ˆè€—ä¾¿å‡å°‘(1)ç‚¹', 
                effects: ['cost-reduction'], 
                costReduction: 'health-lost',
                rarity: 'epic' 
            },
            { 
                id: 13, 
                name: 'è“è…®æˆ˜å£«', 
                type: 'minion', 
                cost: 3, 
                attack: 3, 
                health: 3,
                baseHealth: 3, 
                description: 'å†²é”‹', 
                effects: ['charge'],
                rarity: 'common' 
            },
            { 
                id: 14, 
                name: 'æ¯’æ¶²ä¹‹è›‡', 
                type: 'minion', 
                cost: 2, 
                attack: 1, 
                health: 3,
                baseHealth: 3, 
                description: 'å‰§æ¯’', 
                effects: ['poisonous'],
                rarity: 'rare' 
            },
            { 
                id: 15, 
                name: 'é˜²å¾¡è€…', 
                type: 'minion', 
                cost: 4, 
                attack: 2, 
                health: 6,
                baseHealth: 6, 
                description: 'å˜²è®½', 
                effects: ['taunt'],
                rarity: 'common' 
            },
            
            // æ³•æœ¯å¡ç‰Œ
            { 
                id: 16, 
                name: 'ç«çƒæœ¯', 
                type: 'spell', 
                cost: 4, 
                description: 'é€ æˆ6ç‚¹ä¼¤å®³', 
                effect: 'damage', 
                value: 6, 
                targetType: 'any',
                rarity: 'common' 
            },
            { 
                id: 17, 
                name: 'æ²»ç–—ä¹‹è§¦', 
                type: 'spell', 
                cost: 3, 
                description: 'æ¢å¤8ç‚¹ç”Ÿå‘½å€¼', 
                effect: 'heal', 
                value: 8, 
                targetType: 'friendly',
                rarity: 'common' 
            },
            { 
                id: 18, 
                name: 'é­”çˆ†æœ¯', 
                type: 'spell', 
                cost: 2, 
                description: 'å¯¹æ‰€æœ‰æ•Œæ–¹éšä»é€ æˆ1ç‚¹ä¼¤å®³', 
                effect: 'aoe-damage', 
                value: 1, 
                targetType: 'enemy-minions',
                rarity: 'common' 
            },
            { 
                id: 19, 
                name: 'å¥¥æœ¯æ™ºæ…§', 
                type: 'spell', 
                cost: 3, 
                description: 'æŠ½2å¼ ç‰Œ', 
                effect: 'draw', 
                value: 2, 
                targetType: 'none',
                rarity: 'common' 
            },
            { 
                id: 20, 
                name: 'åˆ€æ‰‡', 
                type: 'spell', 
                cost: 2, 
                description: 'å¯¹æ‰€æœ‰æ•Œæ–¹éšä»é€ æˆ1ç‚¹ä¼¤å®³ï¼ŒæŠ½1å¼ ç‰Œ', 
                effect: 'fan-of-knives', 
                value: 1, 
                targetType: 'none',
                rarity: 'common' 
            },
            { 
                id: 21, 
                name: 'æš—è¨€æœ¯ï¼šæ¯', 
                type: 'spell', 
                cost: 5, 
                description: 'æ¶ˆç­ä¸€ä¸ªæ•Œæ–¹éšä»', 
                effect: 'destroy', 
                targetType: 'enemy-minion',
                rarity: 'rare' 
            },
            { 
                id: 22, 
                name: 'åŠ›é‡ç¥ç¦', 
                type: 'spell', 
                cost: 1, 
                description: 'ä½¿ä¸€ä¸ªéšä»è·å¾—+3æ”»å‡»åŠ›', 
                effect: 'buff-attack', 
                value: 3, 
                targetType: 'friendly-minion',
                rarity: 'common' 
            },
            { 
                id: 23, 
                name: 'ç¥åœ£æ–°æ˜Ÿ', 
                type: 'spell', 
                cost: 5, 
                description: 'å¯¹æ‰€æœ‰æ•Œæ–¹éšä»é€ æˆ2ç‚¹ä¼¤å®³ï¼Œä¸ºæ‰€æœ‰å‹æ–¹è§’è‰²æ¢å¤2ç‚¹ç”Ÿå‘½å€¼', 
                effect: 'holy-nova', 
                value: 2, 
                targetType: 'none',
                rarity: 'rare' 
            },
            { 
                id: 24, 
                name: 'çƒˆç„°é£æš´', 
                type: 'spell', 
                cost: 7, 
                description: 'å¯¹æ‰€æœ‰æ•Œæ–¹è§’è‰²é€ æˆ4ç‚¹ä¼¤å®³', 
                effect: 'flamestrike', 
                value: 4, 
                targetType: 'none',
                rarity: 'rare' 
            },
            { 
                id: 25, 
                name: 'ææƒ§å’†å“®', 
                type: 'spell', 
                cost: 2, 
                description: 'ä½¿æ‰€æœ‰æ•Œæ–¹éšä»å›åˆ°å¯¹æ‰‹æ‰‹ç‰Œ', 
                effect: 'return-minions', 
                targetType: 'none',
                rarity: 'rare' 
            },
            
            // æ­¦å™¨å¡ç‰Œ
            { 
                id: 26, 
                name: 'æˆ˜æ–§', 
                type: 'weapon', 
                cost: 3, 
                attack: 3, 
                durability: 2, 
                description: '', 
                effects: [],
                rarity: 'common' 
            },
            { 
                id: 27, 
                name: 'åˆºå®¢ä¹‹åˆƒ', 
                type: 'weapon', 
                cost: 5, 
                attack: 3, 
                durability: 4, 
                description: 'ä½ çš„è‹±é›„å…ç–«ä¼¤å®³ï¼Œç›´åˆ°ä½ çš„ä¸‹ä¸ªå›åˆ', 
                effects: ['immunity'], 
                immunityEffect: 'next-turn',
                rarity: 'epic' 
            },
            
            // é¢å¤–å¡ç‰Œ
            { 
                id: 28, 
                name: 'æ­»ç¥ä¹‹åˆƒ', 
                type: 'minion', 
                cost: 7, 
                attack: 5, 
                health: 2,
                baseHealth: 2, 
                description: 'å†²é”‹ï¼Œäº¡è¯­ï¼šå¯¹æ•Œæ–¹è‹±é›„é€ æˆ5ç‚¹ä¼¤å®³', 
                effects: ['charge'], 
                deathrattle: 'hero-damage',
                rarity: 'legendary' 
            },
            { 
                id: 29, 
                name: 'æ€¥é€ŸåŒ»ç–—', 
                type: 'spell', 
                cost: 1, 
                description: 'æ¢å¤3ç‚¹ç”Ÿå‘½å€¼ï¼Œè·å¾—+1ä¸´æ—¶æ³•åŠ›æ°´æ™¶', 
                effect: 'heal-and-mana', 
                value: 3, 
                targetType: 'friendly',
                rarity: 'common' 
            },
            { 
                id: 30, 
                name: 'è¿…çŒ›é¾™', 
                type: 'minion', 
                cost: 2, 
                attack: 3, 
                health: 1,
                baseHealth: 1, 
                description: 'æˆ˜å¼ï¼šè·å¾—+1ç‚¹ç”Ÿå‘½å€¼ï¼Œæ¯å›åˆæ”»å‡»åŠ›+1', 
                effects: ['growing'], 
                growEffect: 'attack+1',
                battlecry: 'gain-health',
                growValue: 1,
                rarity: 'rare' 
            }
        ];
        
        // æ¸¸æˆåˆå§‹åŒ–
        function initGame() {
            gameState.playerHealth = 30;
            gameState.playerMaxHealth = 30;
            gameState.opponentHealth = 30;
            gameState.opponentMaxHealth = 30;
            gameState.playerArmor = 0;
            gameState.opponentArmor = 0;
            gameState.playerMana = 1;
            gameState.playerMaxMana = 1;
            gameState.playerTempMana = 0;
            gameState.opponentMana = 1;
            gameState.opponentMaxMana = 1;
            gameState.opponentTempMana = 0;
            gameState.currentTurn = 'player';
            gameState.turnCount = 1;
            gameState.playerHand = [];
            gameState.opponentHand = [];
            gameState.playerMinions = [];
            gameState.opponentMinions = [];
            gameState.playerGraveyard = [];
            gameState.opponentGraveyard = [];
            gameState.playerFatigueDamage = 0;
            gameState.opponentFatigueDamage = 0;
            gameState.playerWeapon = null;
            gameState.opponentWeapon = null;
            gameState.gameOver = false;
            gameState.gameStarted = true;

            // è®¾ç½®å›åˆæŒ‡ç¤ºå™¨
            document.getElementById('turn-indicator').textContent = 'ä½ çš„å›åˆ';
            document.getElementById('turn-indicator').classList.remove('enemy-turn');
            
            // æ·»åŠ å½“å‰å›åˆé«˜äº®
            document.getElementById('player-area').classList.add('current-turn');
            document.getElementById('opponent-area').classList.remove('current-turn');
            
            // åˆ›å»ºç‰Œåº“
            gameState.playerDeck = createDeck();
            gameState.opponentDeck = createDeck();
            
            // æ´—ç‰Œ
            shuffleDeck(gameState.playerDeck);
            shuffleDeck(gameState.opponentDeck);
            
            // æ›´æ–°ç‰Œåº“è®¡æ•°
            document.getElementById('player-deck-count').textContent = gameState.playerDeck.length;
            document.getElementById('opponent-deck-count').textContent = gameState.opponentDeck.length;
            
            // åˆå§‹æŠ½ç‰Œ
            for (let i = 0; i < 3; i++) {
                drawCard('player');
                drawCard('opponent');
            }
            
            // æ›´æ–°æ°´æ™¶æ˜¾ç¤º
            updateManaCrystals('player');
            updateManaCrystals('opponent');
            
            // æ›´æ–°UI
            updateUI();
            
            // è®°å½•æ¸¸æˆå¼€å§‹
            logMessage('æ¸¸æˆå¼€å§‹ï¼', 'system');
            logMessage('ä½ å…ˆæ‰‹ï¼ŒæŠ½åˆ°äº†3å¼ ç‰Œ', 'player');
        }
        
        // åˆ›å»ºç‰Œåº“
        function createDeck() {
            // åˆ›å»ºä¸€ä¸ªæ·±æ‹·è´çš„å¡ç‰Œåº“
            const deck = JSON.parse(JSON.stringify(cardLibrary));
            return deck;
        }
        
        // æ´—ç‰Œç®—æ³•
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }
        
        // æŠ½ç‰Œ
        function drawCard(player) {
            const deck = player === 'player' ? gameState.playerDeck : gameState.opponentDeck;
            const hand = player === 'player' ? gameState.playerHand : gameState.opponentHand;
            
            if (deck.length === 0) {
                // ç–²åŠ³ä¼¤å®³
                const damage = (player === 'player' ? gameState.playerFatigueDamage || 0 : gameState.opponentFatigueDamage || 0) + 1;
                if (player === 'player') {
                    gameState.playerFatigueDamage = damage;
                    dealDamageToHero('player', damage);
                    logMessage(`ä½ å—åˆ°${damage}ç‚¹ç–²åŠ³ä¼¤å®³ï¼`, 'player', 'damage');
                    document.getElementById('player-fatigue').classList.add('active');
                    document.getElementById('player-fatigue').querySelector('span').textContent = damage;
                } else {
                    gameState.opponentFatigueDamage = damage;
                    dealDamageToHero('opponent', damage);
                    logMessage(`å¯¹æ‰‹å—åˆ°${damage}ç‚¹ç–²åŠ³ä¼¤å®³ï¼`, 'opponent', 'damage');
                    document.getElementById('opponent-fatigue').classList.add('active');
                    document.getElementById('opponent-fatigue').querySelector('span').textContent = damage;
                }
                checkGameOver();
                return null;
            }
            
            if (hand.length >= 10) {
                const burnedCard = deck.shift();
                logMessage(`${player === 'player' ? 'ä½ ' : 'å¯¹æ‰‹'}çš„æ‰‹ç‰Œå·²æ»¡ï¼Œ${burnedCard.name}è¢«ç„šçƒ§ï¼`, player === 'player' ? 'player' : 'opponent');
                updateDeckCount(player);
                return null;
            }
            
            const card = deck.shift();
            // ä¸ºæ¯å¼ ç‰Œæ·»åŠ å”¯ä¸€ID
            card.uniqueId = Date.now() + Math.random().toString(36).substr(2, 9);
            
            // ä¸ºå·¨äººç­‰æœ‰æ¡ä»¶è´¹ç”¨çš„ç‰Œè®¡ç®—çœŸå®è´¹ç”¨
            if (card.effects && card.effects.includes('cost-reduction')) {
                if (card.costReduction === 'health-lost') {
                    const healthLost = player === 'player' 
                        ? gameState.playerMaxHealth - gameState.playerHealth 
                        : gameState.opponentMaxHealth - gameState.opponentHealth;
                    card.currentCost = Math.max(0, card.cost - healthLost);
                }
            } else {
                card.currentCost = card.cost;
            }
            
            hand.push(card);
            updateDeckCount(player);
            
            if (player === 'player') {
                // æ·»åŠ å¡ç‰ŒåŠ¨ç”»ç±»
                setTimeout(() => {
                    const cardElement = document.querySelector(`.card[data-id="${card.uniqueId}"]`);
                    if (cardElement) {
                        cardElement.classList.add('card-being-played');
                        setTimeout(() => {
                            cardElement.classList.remove('card-being-played');
                        }, 500);
                    }
                }, 100);
                
                logMessage(`ä½ æŠ½åˆ°äº†${card.name}ï¼`, 'player');
            } else {
                logMessage(`å¯¹æ‰‹æŠ½äº†ä¸€å¼ ç‰Œ`, 'opponent');
            }
            
            return card;
        }
        
        // æ›´æ–°ç‰Œåº“è®¡æ•°
        function updateDeckCount(player) {
            const deck = player === 'player' ? gameState.playerDeck : gameState.opponentDeck;
            document.getElementById(`${player}-deck-count`).textContent = deck.length;
        }
        
        // æ›´æ–°æ³•åŠ›æ°´æ™¶æ˜¾ç¤º
        function updateManaCrystals(player) {
            const container = document.getElementById(`${player}-crystals`);
            container.innerHTML = '';
            
            const maxMana = player === 'player' ? gameState.playerMaxMana : gameState.opponentMaxMana;
            const currentMana = player === 'player' ? gameState.playerMana : gameState.opponentMana;
            const tempMana = player === 'player' ? gameState.playerTempMana : gameState.opponentTempMana;
            
            for (let i = 0; i < 10; i++) {
                const crystal = document.createElement('div');
                crystal.className = 'crystal';
                
                if (i < currentMana) {
                    crystal.classList.add('filled');
                }
                
                if (i >= maxMana && i < maxMana + tempMana) {
                    crystal.classList.add('temporary');
                }
                
                container.appendChild(crystal);
            }
        }
        
        // æ›´æ–°UI
        function updateUI() {
            // æ›´æ–°ç©å®¶ä¿¡æ¯
            document.getElementById('player-health').textContent = gameState.playerHealth;
            document.getElementById('player-mana').textContent = gameState.playerMana;
            document.getElementById('player-max-mana').textContent = gameState.playerMaxMana;
            
            // æ›´æ–°æŠ¤ç”²
            if (gameState.playerArmor > 0) {
                document.getElementById('player-armor').style.display = 'flex';
                document.getElementById('player-armor').textContent = gameState.playerArmor;
            } else {
                document.getElementById('player-armor').style.display = 'none';
            }
            
            // æ›´æ–°å¯¹æ‰‹ä¿¡æ¯
            document.getElementById('opponent-health').textContent = gameState.opponentHealth;
            document.getElementById('opponent-mana').textContent = gameState.opponentMana;
            document.getElementById('opponent-max-mana').textContent = gameState.opponentMaxMana;
            
            // æ›´æ–°å¯¹æ‰‹æŠ¤ç”²
            if (gameState.opponentArmor > 0) {
                document.getElementById('opponent-armor').style.display = 'flex';
                document.getElementById('opponent-armor').textContent = gameState.opponentArmor;
            } else {
                document.getElementById('opponent-armor').style.display = 'none';
            }
            
            // æ›´æ–°ç©å®¶æ‰‹ç‰Œ
            updateHand('player');
            
            // æ›´æ–°å¯¹æ‰‹æ‰‹ç‰Œ
            updateHand('opponent');
            
            // æ›´æ–°ç©å®¶éšä»åŒº
            updateMinionsArea('player');
            
            // æ›´æ–°å¯¹æ‰‹éšä»åŒº
            updateMinionsArea('opponent');
            
            // æ›´æ–°æ­¦å™¨æ˜¾ç¤º
            updateWeaponDisplay();
            
            // æ›´æ–°æ³•åŠ›æ°´æ™¶
            updateManaCrystals('player');
            updateManaCrystals('opponent');
        }
        
        // æ›´æ–°æ‰‹ç‰ŒåŒºåŸŸ
        function updateHand(player) {
            const handElement = document.getElementById(`${player}-hand`);
            handElement.innerHTML = '';
            
            const hand = player === 'player' ? gameState.playerHand : gameState.opponentHand;
            
            hand.forEach(card => {
                const cardElement = document.createElement('div');
                cardElement.className = 'card';
                cardElement.dataset.id = card.uniqueId;
                
                // å¯¹æ‰‹çš„ç‰ŒèƒŒé¢æœä¸Š
                if (player === 'opponent') {
                    cardElement.className = 'card card-back';
                    handElement.appendChild(cardElement);
                    return;
                }
                
                // æ£€æŸ¥ç‰Œæ˜¯å¦å¯ä»¥ä½¿ç”¨ï¼ˆè¶³å¤Ÿçš„æ³•åŠ›å€¼ï¼‰
                if (card.currentCost <= gameState.playerMana) {
                    cardElement.classList.add('playable');
                } else {
                    cardElement.classList.add('not-playable');
                }
                
                // å¡ç‰Œç¨€æœ‰åº¦æ ‡è®°
                const rarityClass = `rarity-${card.rarity || 'common'}`;
                
                let cardContent = `
                    <div class="card-cost">${card.currentCost || card.cost}</div>
                    <div class="card-rarity ${rarityClass}"></div>
                    <div class="card-name">${card.name}</div>
                    <div class="card-description">${card.description}</div>
                    <div class="card-glare"></div>
                `;
                
                if (card.type === 'minion') {
                    cardContent += `
                        <div class="card-stats">
                            <div class="card-attack">${card.attack}</div>
                            <div class="card-health">${card.health}</div>
                        </div>
                        <div class="card-type-icon">éš</div>
                    `;
                } else if (card.type === 'weapon') {
                    cardContent += `
                        <div class="card-stats">
                            <div class="card-attack">${card.attack}</div>
                            <div class="card-durability">${card.durability}</div>
                        </div>
                        <div class="card-type-icon">æ­¦</div>
                    `;
                } else if (card.type === 'spell') {
                    cardContent += `<div class="card-type-icon">æ³•</div>`;
                }
                
                cardElement.innerHTML = cardContent;
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                cardElement.addEventListener('click', () => {
                    if (gameState.currentTurn === 'player' && !gameState.gameOver) {
                        selectCard(card);
                    }
                });
                
                handElement.appendChild(cardElement);
            });
        }
        
        // æ›´æ–°éšä»åŒº
        function updateMinionsArea(player) {
            const minionsArea = document.getElementById(`${player}-minions`);
            minionsArea.innerHTML = '';
            
            const minions = player === 'player' ? gameState.playerMinions : gameState.opponentMinions;
            
            minions.forEach(minion => {
                const minionEl = document.createElement('div');
                let classNames = 'minion';
                
                // æ·»åŠ éšä»ç‰¹æ•ˆçš„ç±»
                if (minion.effects.includes('taunt')) {
                    classNames += ' taunt';
                }
                if (minion.effects.includes('divine-shield')) {
                    classNames += ' divine-shield';
                }
                if (minion.effects.includes('poisonous')) {
                    classNames += ' poisonous';
                }
                
                // æ·»åŠ çŠ¶æ€ç±»
                if (minion.health < minion.baseHealth) {
                    classNames += ' damaged';
                }
                if (minion.attack > cardLibrary.find(c => c.id === minion.id).attack) {
                    classNames += ' buffed';
                }
                
                // æ·»åŠ ç–²åŠ³çŠ¶æ€
                if (minion.hasAttacked || (player === 'player' && gameState.currentTurn !== 'player')) {
                    classNames += ' exhausted';
                } else if (!minion.hasAttacked && player === 'player' && gameState.currentTurn === 'player') {
                    classNames += ' can-attack';
                }
                
                // æ·»åŠ æ²‰ç¡çŠ¶æ€ï¼ˆæ— æ³•æ”»å‡»çš„éšä»ï¼‰
                if (!minion.effects.includes('charge') && minion.justPlayed && player === 'player') {
                    classNames += ' sleeping';
                }
                
                minionEl.className = classNames;
                minionEl.dataset.id = minion.uniqueId;
                
                let effectsHtml = '';
                if (minion.effects.length > 0) {
                    effectsHtml = '<div class="minion-effects">';
                    if (minion.effects.includes('taunt')) {
                        effectsHtml += '<span class="effect">å˜²è®½</span>';
                    }
                    if (minion.effects.includes('divine-shield')) {
                        effectsHtml += '<span class="effect">åœ£ç›¾</span>';
                    }
                    if (minion.effects.includes('charge')) {
                        effectsHtml += '<span class="effect">å†²é”‹</span>';
                    }
                    if (minion.effects.includes('spell-damage')) {
                        effectsHtml += `<span class="effect">æ³•æœ¯+${minion.spellDamage}</span>`;
                    }
                    if (minion.effects.includes('growing')) {
                        effectsHtml += `<span class="effect">æˆé•¿</span>`;
                    }
                    if (minion.effects.includes('cant-attack-hero')) {
                        effectsHtml += `<span class="effect">é™æ”»</span>`;
                    }
                    effectsHtml += '</div>';
                }
                
                minionEl.innerHTML = `
                    <div class="minion-name">${minion.name}</div>
                    ${effectsHtml}
                    <div class="minion-stats">
                        <div class="minion-attack">${minion.attack}</div>
                        <div class="minion-health">${minion.health}</div>
                    </div>
                    <div class="card-glare"></div>
                `;
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                minionEl.addEventListener('click', () => {
                    if (gameState.gameOver) return;
                    
                    if (player === 'player') {
                        // é€‰æ‹©å·±æ–¹éšä»è¿›è¡Œæ”»å‡»
                        if (gameState.currentTurn === 'player' && !gameState.selectedCard && !minion.hasAttacked && !minion.justPlayed) {
                            selectMinion(minion);
                        } else if (gameState.selectedCard && gameState.selectedCard.type === 'spell') {
                            // ä½¿ç”¨æ³•æœ¯ç‰Œé€‰æ‹©å·±æ–¹éšä»ä½œä¸ºç›®æ ‡
                            const spell = gameState.selectedCard;
                            if ((spell.targetType === 'friendly' || spell.targetType === 'friendly-minion' || spell.targetType === 'any') && 
                                canTargetMinion(minion, spell.targetType)) {
                                useSpell(spell, minion);
                            }
                        }
                    } else if (gameState.currentTurn === 'player') {
                        // å¯¹æ•Œæ–¹éšä»ä½¿ç”¨æ³•æœ¯æˆ–æ”»å‡»
                        if (gameState.selectedCard && gameState.selectedCard.type === 'spell') {
                            // å¯¹æ•Œæ–¹éšä»ä½¿ç”¨æ³•æœ¯
                            const spell = gameState.selectedCard;
                            if ((spell.targetType === 'any' || spell.targetType === 'enemy' || spell.targetType === 'enemy-minion') && 
                                canTargetMinion(minion, spell.targetType)) {
                                useSpell(spell, minion);
                            }
                        } else if (gameState.selectedMinion) {
                            // å·±æ–¹éšä»æ”»å‡»æ•Œæ–¹éšä»
                            attackMinion(gameState.selectedMinion, minion);
                        }
                    }
                });
                
                minionsArea.appendChild(minionEl);
            });
        }
        
        // æ›´æ–°æ­¦å™¨æ˜¾ç¤º
        function updateWeaponDisplay() {
            const weaponContainer = document.getElementById('player-weapon-container');
            const weaponAttack = document.getElementById('weapon-attack');
            const weaponDurability = document.getElementById('weapon-durability');
            
            if (gameState.playerWeapon) {
                weaponContainer.style.display = 'flex';
                weaponAttack.textContent = gameState.playerWeapon.attack;
                weaponDurability.textContent = gameState.playerWeapon.durability;
            } else {
                weaponContainer.style.display = 'none';
            }
        }
        
        // é€‰æ‹©å¡ç‰Œ
        function selectCard(card) {
            // å–æ¶ˆä¹‹å‰çš„é€‰æ‹©
            gameState.selectedCard = null;
            gameState.selectedMinion = null;
            
            // æ£€æŸ¥æ˜¯å¦èƒ½ä½¿ç”¨æ­¤å¡
            if (card.currentCost > gameState.playerMana) {
                logMessage(`æ³•åŠ›å€¼ä¸è¶³ï¼Œæ— æ³•ä½¿ç”¨${card.name}ï¼`, 'player');
                return;
            }
            
            // é€‰æ‹©å¡ç‰Œ
            gameState.selectedCard = card;
            
            // å¦‚æœæ˜¯éšä»ç‰Œï¼Œæ£€æŸ¥æ˜¯å¦è¿˜æœ‰ä½ç½®
            if (card.type === 'minion' && gameState.playerMinions.length >= 7) {
                logMessage('éšä»ä½ç½®å·²æ»¡ï¼Œæ— æ³•å¬å”¤æ›´å¤šéšä»ï¼', 'player');
                gameState.selectedCard = null;
                return;
            }
            
            // å¦‚æœæ˜¯æ³•æœ¯ç‰Œï¼Œå¤„ç†ç›®æ ‡é€‰æ‹©
            if (card.type === 'spell') {
                if (card.targetType === 'none') {
                    // æ— éœ€ç›®æ ‡çš„æ³•æœ¯ç›´æ¥ä½¿ç”¨
                    useSpell(card);
                } else if (card.targetType === 'enemy-minions' || card.targetType === 'all-minions') {
                    // ç¾¤ä½“æ³•æœ¯ç›´æ¥ä½¿ç”¨
                    useSpell(card);
                } else {
                    // éœ€è¦é€‰æ‹©ç›®æ ‡çš„æ³•æœ¯
                    logMessage(`è¯·é€‰æ‹©${card.name}çš„ç›®æ ‡`, 'system');
                    
                    // æ ¹æ®æ³•æœ¯ç›®æ ‡ç±»å‹æ˜¾ç¤ºæœ‰æ•ˆç›®æ ‡çš„é«˜äº®æˆ–å¼¹å‡ºé€‰æ‹©æ¡†
                    if (card.targetType === 'friendly-hero' || card.targetType === 'friendly') {
                        document.getElementById('player-portrait').classList.add('can-target');
                    } else if (card.targetType === 'enemy-hero' || card.targetType === 'enemy' || card.targetType === 'any') {
                        document.getElementById('opponent-portrait').classList.add('can-target');
                    }
                }
            } else if (card.type === 'minion') {
                // ç›´æ¥ä½¿ç”¨éšä»ç‰Œ
                playMinion(card);
            } else if (card.type === 'weapon') {
                // ç›´æ¥è£…å¤‡æ­¦å™¨
                equipWeapon(card);
            }
        }
        
        // é€‰æ‹©éšä»è¿›è¡Œæ”»å‡»
        function selectMinion(minion) {
            if (minion.hasAttacked || minion.justPlayed) {
                logMessage(`${minion.name}å·²ç»æ”»å‡»è¿‡äº†æˆ–åˆšåˆšè¢«å¬å”¤ï¼`, 'player');
                return;
            }
            
            gameState.selectedCard = null;
            gameState.selectedMinion = minion;
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ•Œæ–¹å˜²è®½éšä»
            const hasTaunt = gameState.opponentMinions.some(m => m.effects.includes('taunt'));
            
            // é«˜äº®å¯æ”»å‡»ç›®æ ‡
            if (hasTaunt) {
                // åªæœ‰å˜²è®½éšä»å¯ä»¥è¢«æ”»å‡»
                gameState.opponentMinions.forEach(m => {
                    if (m.effects.includes('taunt')) {
                        const minionEl = document.querySelector(`.minion[data-id="${m.uniqueId}"]`);
                        if (minionEl) minionEl.classList.add('can-target');
                    }
                });
            } else {
                // æ‰€æœ‰æ•Œæ–¹éšä»å’Œè‹±é›„éƒ½å¯ä»¥æ”»å‡»
                gameState.opponentMinions.forEach(m => {
                    const minionEl = document.querySelector(`.minion[data-id="${m.uniqueId}"]`);
                    if (minionEl) minionEl.classList.add('can-target');
                });
                
                // å¦‚æœéšä»å¯ä»¥æ”»å‡»è‹±é›„ï¼ˆæ²¡æœ‰cant-attack-heroæ•ˆæœï¼‰
                if (!minion.effects.includes('cant-attack-hero')) {
                    document.getElementById('opponent-portrait').classList.add('can-target');
                }
            }
            
            logMessage(`é€‰æ‹©${minion.name}æ”»å‡»ç›®æ ‡`, 'player');
        }
        
        // ä½¿ç”¨éšä»ç‰Œ
        function playMinion(card) {
            // æ‰£é™¤æ³•åŠ›å€¼
            gameState.playerMana -= card.currentCost;
            
            // ä»æ‰‹ç‰Œä¸­ç§»é™¤
            gameState.playerHand = gameState.playerHand.filter(c => c.uniqueId !== card.uniqueId);
            
            // åˆ›å»ºéšä»å¯¹è±¡
            const minion = {
                ...card,
                hasAttacked: true, // é»˜è®¤å¬å”¤åä¸èƒ½æ”»å‡»ï¼Œé™¤éæœ‰å†²é”‹
                justPlayed: true,  // æ ‡è®°ä¸ºåˆšåˆšè¢«å¬å”¤
                originalAttack: card.attack, // è®°å½•åŸå§‹æ”»å‡»åŠ›ï¼Œç”¨äºå…‰ç¯æ•ˆæœ
                originalHealth: card.health, // è®°å½•åŸå§‹ç”Ÿå‘½å€¼
                baseHealth: card.baseHealth || card.health // è®°å½•åŸºç¡€ç”Ÿå‘½å€¼ä¸Šé™
            };
            
            // å¦‚æœæœ‰å†²é”‹æ•ˆæœï¼Œåˆ™å¯ä»¥ç«‹å³æ”»å‡»
            if (minion.effects.includes('charge')) {
                minion.hasAttacked = false;
                minion.justPlayed = false;
            }
            
            // æ·»åŠ åˆ°åœºä¸Š
            gameState.playerMinions.push(minion);
            
            // æ·»åŠ éšä»å…¥åœºåŠ¨ç”»
            setTimeout(() => {
                const minionElement = document.querySelector(`.minion[data-id="${minion.uniqueId}"]`);
                if (minionElement) {
                    minionElement.classList.add('card-being-played');
                    setTimeout(() => {
                        minionElement.classList.remove('card-being-played');
                    }, 500);
                }
            }, 100);
            
            logMessage(`ä½ ä½¿ç”¨äº†${card.name}ï¼`, 'player');
            
            // å¤„ç†æˆ˜å¼æ•ˆæœ
            if (minion.battlecry) {
                handleBattlecry(minion);
            }
            
            // åº”ç”¨å…‰ç¯æ•ˆæœ
            applyAuraEffects();
            
            // æ›´æ–°UI
            updateUI();
        }
        
        // å¤„ç†æˆ˜å¼æ•ˆæœ
        function handleBattlecry(minion) {
            switch (minion.battlecry) {
                case 'draw':
                    drawCard('player');
                    break;
                case 'damage-all-enemy-minions':
                    damageAllEnemyMinions(1);
                    break;
                case 'damage-all-minions':
                    // å¯¹æ‰€æœ‰éšä»é€ æˆä¼¤å®³
                    gameState.playerMinions.forEach(m => {
                        damageMinion(m, 1, 'player');
                    });
                    gameState.opponentMinions.forEach(m => {
                        damageMinion(m, 1, 'opponent');
                    });
                    break;
                case 'gain-health':
                    // å¢åŠ ç”Ÿå‘½å€¼
                    minion.health += 1;
                    minion.baseHealth += 1;
                    logMessage(`${minion.name}è·å¾—äº†+1ç”Ÿå‘½å€¼ï¼`, 'player');
                    break;
            }
        }
        
        // åº”ç”¨å…‰ç¯æ•ˆæœ
        function applyAuraEffects() {
            // é‡ç½®æ‰€æœ‰éšä»çš„æ”»å‡»åŠ›
            gameState.playerMinions.forEach(minion => {
                minion.attack = minion.originalAttack;
            });
            
            // åº”ç”¨ç©å®¶éšä»çš„å…‰ç¯æ•ˆæœ
            gameState.playerMinions.forEach(auraMinion => {
                if (auraMinion.effects.includes('aura')) {
                    if (auraMinion.auraEffect === 'attack+1') {
                        gameState.playerMinions.forEach(targetMinion => {
                            if (targetMinion.uniqueId !== auraMinion.uniqueId) {
                                targetMinion.attack += 1;
                            }
                        });
                    }
                }
            });
            
            // ç±»ä¼¼åœ°å¤„ç†å¯¹æ‰‹éšä»çš„å…‰ç¯
            gameState.opponentMinions.forEach(minion => {
                minion.attack = minion.originalAttack;
            });
            
            gameState.opponentMinions.forEach(auraMinion => {
                if (auraMinion.effects.includes('aura')) {
                    if (auraMinion.auraEffect === 'attack+1') {
                        gameState.opponentMinions.forEach(targetMinion => {
                            if (targetMinion.uniqueId !== auraMinion.uniqueId) {
                                targetMinion.attack += 1;
                            }
                        });
                    }
                }
            });
        }
        
        // å¯¹æ‰€æœ‰æ•Œæ–¹éšä»é€ æˆä¼¤å®³
        function damageAllEnemyMinions(damage) {
            // è®¡ç®—æ³•æœ¯ä¼¤å®³åŠ æˆ
            let spellDamageBonus = calculateSpellDamage('player');
            const totalDamage = damage + spellDamageBonus;
            
            gameState.opponentMinions.forEach(minion => {
                damageMinion(minion, totalDamage, 'opponent');
            });
            
            // æ¸…ç†æ­»äº¡éšä»
            cleanupDeadMinions();
        }
        
        // è®¡ç®—æ³•æœ¯ä¼¤å®³åŠ æˆ
        function calculateSpellDamage(player) {
            let spellDamageBonus = 0;
            const minions = player === 'player' ? gameState.playerMinions : gameState.opponentMinions;
            
            minions.forEach(minion => {
                if (minion.effects.includes('spell-damage')) {
                    spellDamageBonus += minion.spellDamage || 1;
                }
            });
            
            return spellDamageBonus;
        }
        
        // ä½¿ç”¨æ³•æœ¯
        function useSpell(spell, target = null) {
            // æ ‡è®°æ³•æœ¯æ­£åœ¨ä½¿ç”¨ä¸­
            gameState.spellInProgress = true;
            
            // æ‰£é™¤æ³•åŠ›å€¼
            gameState.playerMana -= spell.cost;
            
            // ä»æ‰‹ç‰Œä¸­ç§»é™¤
            gameState.playerHand = gameState.playerHand.filter(c => c.uniqueId !== spell.uniqueId);
            
            logMessage(`ä½ ä½¿ç”¨äº†${spell.name}ï¼`, 'player');
            
            // è®¡ç®—æ³•æœ¯ä¼¤å®³åŠ æˆ
            let spellDamageBonus = calculateSpellDamage('player');
            
            // å¤„ç†æ³•æœ¯æ•ˆæœ
            switch (spell.effect) {
                case 'damage':
                    // å¯¹å•ä¸ªç›®æ ‡é€ æˆä¼¤å®³
                    if (target) {
                        const totalDamage = spell.value + spellDamageBonus;
                        if (target.type === 'minion') {
                            damageMinion(target, totalDamage, target.side || 'opponent');
                        } else if (target === 'opponent') {
                            dealDamageToHero('opponent', totalDamage);
                            animateHeroDamage('opponent');
                            logMessage(`å¯¹æ‰‹å—åˆ°${totalDamage}ç‚¹ä¼¤å®³ï¼`, 'opponent', 'damage');
                        } else if (target === 'player') {
                            dealDamageToHero('player', totalDamage);
                            animateHeroDamage('player');
                            logMessage(`ä½ å—åˆ°${totalDamage}ç‚¹ä¼¤å®³ï¼`, 'player', 'damage');
                        }
                    }
                    break;
                    
                case 'heal':
                    // æ¢å¤ç”Ÿå‘½å€¼
                    if (target) {
                        if (target.type === 'minion') {
                            healMinion(target, spell.value);
                        } else if (target === 'player') {
                            healHero('player', spell.value);
                            logMessage(`ä½ æ¢å¤äº†${spell.value}ç‚¹ç”Ÿå‘½å€¼ï¼`, 'player', 'heal');
                        } else if (target === 'opponent') {
                            healHero('opponent', spell.value);
                            logMessage(`å¯¹æ‰‹æ¢å¤äº†${spell.value}ç‚¹ç”Ÿå‘½å€¼ï¼`, 'opponent', 'heal');
                        }
                    }
                    break;
                    
                case 'heal-and-mana':
                    // æ¢å¤ç”Ÿå‘½å€¼å¹¶å¢åŠ ä¸´æ—¶æ³•åŠ›æ°´æ™¶
                    if (target) {
                        if (target.type === 'minion') {
                            healMinion(target, spell.value);
                        } else if (target === 'player') {
                            healHero('player', spell.value);
                            gameState.playerTempMana += 1;
                            gameState.playerMana += 1;
                            logMessage(`ä½ æ¢å¤äº†${spell.value}ç‚¹ç”Ÿå‘½å€¼ï¼Œå¹¶è·å¾—äº†1ä¸ªä¸´æ—¶æ³•åŠ›æ°´æ™¶ï¼`, 'player', 'heal');
                        } else if (target === 'opponent') {
                            healHero('opponent', spell.value);
                            logMessage(`å¯¹æ‰‹æ¢å¤äº†${spell.value}ç‚¹ç”Ÿå‘½å€¼ï¼`, 'opponent', 'heal');
                        }
                    }
                    break;
                    
                case 'aoe-damage':
                    // å¯¹æ‰€æœ‰æ•Œæ–¹éšä»é€ æˆä¼¤å®³
                    const aoeDamage = spell.value + spellDamageBonus;
                    damageAllEnemyMinions(aoeDamage);
                    logMessage(`å¯¹æ‰€æœ‰æ•Œæ–¹éšä»é€ æˆ${aoeDamage}ç‚¹ä¼¤å®³ï¼`, 'player');
                    break;
                    
                case 'draw':
                    // æŠ½ç‰Œ
                    for (let i = 0; i < spell.value; i++) {
                        drawCard('player');
                    }
                    break;
                    
                case 'fan-of-knives':
                    // åˆ€æ‰‡ï¼šä¼¤å®³ + æŠ½ç‰Œ
                    const fanDamage = spell.value + spellDamageBonus;
                    damageAllEnemyMinions(fanDamage);
                    drawCard('player');
                    break;
                    
                case 'destroy':
                    // æ¶ˆç­éšä»
                    if (target && target.type === 'minion') {
                        destroyMinion(target, 'opponent');
                        logMessage(`${target.name}è¢«æ¶ˆç­äº†ï¼`, 'player');
                    }
                    break;
                    
                case 'buff-attack':
                    // æé«˜æ”»å‡»åŠ›
                    if (target && target.type === 'minion') {
                        target.attack += spell.value;
                        target.originalAttack += spell.value;
                        logMessage(`${target.name}è·å¾—äº†+${spell.value}æ”»å‡»åŠ›ï¼`, 'player');
                    }
                    break;
                    
                case 'holy-nova':
                    // ç¥åœ£æ–°æ˜Ÿï¼šå¯¹æ•Œæ–¹éšä»é€ æˆä¼¤å®³ï¼Œä¸ºå‹æ–¹è§’è‰²æ¢å¤ç”Ÿå‘½å€¼
                    const novaDamage = spell.value + spellDamageBonus;
                    damageAllEnemyMinions(novaDamage);
                    
                    // æ¢å¤å‹æ–¹è§’è‰²ç”Ÿå‘½å€¼
                    healHero('player', spell.value);
                    gameState.playerMinions.forEach(minion => {
                        healMinion(minion, spell.value);
                    });
                    logMessage(`ä½ çš„æ‰€æœ‰è§’è‰²æ¢å¤äº†${spell.value}ç‚¹ç”Ÿå‘½å€¼ï¼`, 'player', 'heal');
                    break;
                    
                case 'flamestrike':
                    // çƒˆç„°é£æš´ï¼šå¯¹æ‰€æœ‰æ•Œæ–¹è§’è‰²é€ æˆä¼¤å®³
                    const flamestrikeDamage = spell.value + spellDamageBonus;
                    damageAllEnemyMinions(flamestrikeDamage);
                    dealDamageToHero('opponent', flamestrikeDamage);
                    animateHeroDamage('opponent');
                    logMessage(`å¯¹æ‰‹å—åˆ°${flamestrikeDamage}ç‚¹ä¼¤å®³ï¼`, 'opponent', 'damage');
                    break;
                    
                case 'return-minions':
                    // ææƒ§å’†å“®ï¼šå°†æ‰€æœ‰æ•Œæ–¹éšä»ç§»å›æ‰‹ç‰Œ
                    gameState.opponentMinions.forEach(minion => {
                        if (gameState.opponentHand.length < 10) {
                            gameState.opponentHand.push({...minion, uniqueId: Date.now() + Math.random().toString(36).substr(2, 9)});
                        }
                    });
                    gameState.opponentMinions = [];
                    logMessage(`æ‰€æœ‰æ•Œæ–¹éšä»å›åˆ°äº†å¯¹æ‰‹çš„æ‰‹ç‰Œï¼`, 'player');
                    break;
            }
            
            // æ¸…ç†æ­»äº¡éšä»
            cleanupDeadMinions();
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
            checkGameOver();
            
            // æ›´æ–°UI
            updateUI();
            
            // æ¸…é™¤é€‰æ‹©çŠ¶æ€
            resetTargeting();
            gameState.selectedCard = null;
            gameState.selectedMinion = null;
            
            // ç»“æŸæ³•æœ¯ä½¿ç”¨
            gameState.spellInProgress = false;
        }
        
        // è£…å¤‡æ­¦å™¨
        function equipWeapon(card) {
            // æ‰£é™¤æ³•åŠ›å€¼
            gameState.playerMana -= card.cost;
            
            // ä»æ‰‹ç‰Œä¸­ç§»é™¤
            gameState.playerHand = gameState.playerHand.filter(c => c.uniqueId !== card.uniqueId);
            
            // å¦‚æœæœ‰ç°æœ‰æ­¦å™¨ï¼Œå…ˆé”€æ¯å®ƒ
            if (gameState.playerWeapon) {
                logMessage(`ä½ çš„${gameState.playerWeapon.name}è¢«æ‘§æ¯äº†ï¼`, 'player');
            }
            
            // è£…å¤‡æ–°æ­¦å™¨
            gameState.playerWeapon = {...card};
            
            // å¤„ç†è£…å¤‡æ•ˆæœ
            if (card.effects.includes('immunity') && card.immunityEffect === 'next-turn') {
                gameState.playerImmunity = true;
                logMessage(`ä½ è·å¾—äº†å…ç–«æ•ˆæœï¼Œç›´åˆ°ä¸‹ä¸ªå›åˆï¼`, 'player');
            }
            
            logMessage(`ä½ è£…å¤‡äº†${card.name}ï¼`, 'player');
            
            // æ›´æ–°UI
            updateUI();
            
            // æ¸…é™¤é€‰æ‹©çŠ¶æ€
            gameState.selectedCard = null;
        }
        
        // éšä»æ”»å‡»
        function attackMinion(attacker, defender) {
            // æ£€æŸ¥å˜²è®½
            const hasTaunt = gameState.opponentMinions.some(m => m.effects.includes('taunt'));
            if (hasTaunt && !defender.effects.includes('taunt') && defender.type === 'minion') {
                logMessage(`ä½ å¿…é¡»å…ˆæ”»å‡»å…·æœ‰å˜²è®½çš„éšä»ï¼`, 'player');
                resetTargeting();
                gameState.selectedMinion = null;
                return;
            }
            
            // æ”»å‡»è‹±é›„
            if (defender === 'opponent') {
                // å¦‚æœéšä»ä¸èƒ½æ”»å‡»è‹±é›„
                if (attacker.effects.includes('cant-attack-hero')) {
                    logMessage(`${attacker.name}ä¸èƒ½æ”»å‡»è‹±é›„ï¼`, 'player');
                    resetTargeting();
                    gameState.selectedMinion = null;
                    return;
                }
                
                dealDamageToHero('opponent', attacker.attack);
                animateHeroDamage('opponent');
                logMessage(`${attacker.name}æ”»å‡»äº†å¯¹æ‰‹ï¼Œé€ æˆ${attacker.attack}ç‚¹ä¼¤å®³ï¼`, 'player');
                
                // å¦‚æœæœ‰æ­¦å™¨ï¼Œå‡å°‘è€ä¹…åº¦
                if (gameState.playerWeapon && !attacker.effects.includes('charge')) {
                    gameState.playerWeapon.durability -= 1;
                    if (gameState.playerWeapon.durability <= 0) {
                        logMessage(`ä½ çš„${gameState.playerWeapon.name}è¢«æ‘§æ¯äº†ï¼`, 'player');
                        gameState.playerWeapon = null;
                    }
                }
                
                // æ ‡è®°éšä»å·²æ”»å‡»
                attacker.hasAttacked = true;
                
                // æ›´æ–°UI
                updateUI();
                
                // æ¸…é™¤é€‰æ‹©çŠ¶æ€
                resetTargeting();
                gameState.selectedMinion = null;
                
                return;
            }
            
            logMessage(`${attacker.name}æ”»å‡»äº†${defender.name}ï¼`, 'player');
            
            // å¤„ç†åœ£ç›¾
            if (defender.effects.includes('divine-shield')) {
                defender.effects = defender.effects.filter(e => e !== 'divine-shield');
                logMessage(`${defender.name}çš„åœ£ç›¾è¢«å‡»ç ´äº†ï¼`, 'opponent');
            } else {
                damageMinion(defender, attacker.attack, 'opponent');
            }
            
            if (attacker.effects.includes('divine-shield')) {
                attacker.effects = attacker.effects.filter(e => e !== 'divine-shield');
                logMessage(`${attacker.name}çš„åœ£ç›¾è¢«å‡»ç ´äº†ï¼`, 'player');
            } else {
                damageMinion(attacker, defender.attack, 'player');
            }
            
            // å¤„ç†å‰§æ¯’æ•ˆæœ
            if (attacker.effects.includes('poisonous') && !defender.effects.includes('divine-shield') && defender.health > 0) {
                destroyMinion(defender, 'opponent');
                logMessage(`${defender.name}è¢«æ¯’æ­»äº†ï¼`, 'player');
            }
            
            if (defender.effects.includes('poisonous') && !attacker.effects.includes('divine-shield') && attacker.health > 0) {
                destroyMinion(attacker, 'player');
                logMessage(`${attacker.name}è¢«æ¯’æ­»äº†ï¼`, 'opponent');
            }
            
            // æ ‡è®°éšä»å·²æ”»å‡»
            attacker.hasAttacked = true;
            
            // æ¸…ç†æ­»äº¡éšä»
            cleanupDeadMinions();
            
            // æ›´æ–°UI
            updateUI();
            
            // æ¸…é™¤é€‰æ‹©çŠ¶æ€
            resetTargeting();
            gameState.selectedMinion = null;
        }
        
        // åŠ¨ç”»ï¼šè‹±é›„å—ä¼¤
        function animateHeroDamage(hero) {
            const heroEl = document.getElementById(`${hero}-portrait`);
            heroEl.classList.add('damage-animation');
            setTimeout(() => {
                heroEl.classList.remove('damage-animation');
            }, 500);
        }
        
        // å¯¹éšä»é€ æˆä¼¤å®³
        function damageMinion(minion, damage, owner) {
            const minionEl = document.querySelector(`.minion[data-id="${minion.uniqueId}"]`);
            if (minionEl) {
                minionEl.classList.add('damage-animation');
                setTimeout(() => {
                    minionEl.classList.remove('damage-animation');
                }, 500);
            }
            
            minion.health -= damage;
            logMessage(`${minion.name}å—åˆ°${damage}ç‚¹ä¼¤å®³ï¼`, owner, 'damage');
            
            // æ£€æŸ¥æ˜¯å¦æ­»äº¡
            if (minion.health <= 0) {
                logMessage(`${minion.name}æ­»äº¡äº†ï¼`, owner);
                
                // å¤„ç†äº¡è¯­
                if (minion.deathrattle) {
                    handleDeathrattle(minion, owner);
                }
            }
        }
        
        // å¤„ç†äº¡è¯­
        function handleDeathrattle(minion, owner) {
            switch (minion.deathrattle) {
                case 'hero-damage':
                    // å¯¹æ•Œæ–¹è‹±é›„é€ æˆä¼¤å®³
                    if (owner === 'player') {
                        dealDamageToHero('opponent', 5);
                        animateHeroDamage('opponent');
                        logMessage(`å¯¹æ‰‹å—åˆ°5ç‚¹ä¼¤å®³ï¼`, 'opponent', 'damage');
                    } else {
                        dealDamageToHero('player', 5);
                        animateHeroDamage('player');
                        logMessage(`ä½ å—åˆ°5ç‚¹ä¼¤å®³ï¼`, 'player', 'damage');
                    }
                    break;
            }
        }
        
        // æ¶ˆç­éšä»
        function destroyMinion(minion, owner) {
            if (owner === 'player') {
                gameState.playerMinions = gameState.playerMinions.filter(m => m.uniqueId !== minion.uniqueId);
                gameState.playerGraveyard.push(minion);
            } else {
                gameState.opponentMinions = gameState.opponentMinions.filter(m => m.uniqueId !== minion.uniqueId);
                gameState.opponentGraveyard.push(minion);
            }
            
            // å¤„ç†äº¡è¯­
            if (minion.deathrattle) {
                handleDeathrattle(minion, owner);
            }
        }
        
        // å¯¹è‹±é›„é€ æˆä¼¤å®³
        function dealDamageToHero(hero, damage) {
            if (hero === 'player') {
                // å¦‚æœç©å®¶æœ‰æŠ¤ç”²ï¼Œå…ˆæ¶ˆè€—æŠ¤ç”²
                if (gameState.playerArmor > 0) {
                    if (gameState.playerArmor >= damage) {
                        gameState.playerArmor -= damage;
                        logMessage(`ä½ çš„æŠ¤ç”²å¸æ”¶äº†${damage}ç‚¹ä¼¤å®³ï¼`, 'player');
                        damage = 0;
                    } else {
                        const remainingDamage = damage - gameState.playerArmor;
                        logMessage(`ä½ çš„æŠ¤ç”²å¸æ”¶äº†${gameState.playerArmor}ç‚¹ä¼¤å®³ï¼`, 'player');
                        gameState.playerArmor = 0;
                        damage = remainingDamage;
                    }
                }
                
                // å¤„ç†å‰©ä½™ä¼¤å®³
                if (damage > 0) {
                    gameState.playerHealth -= damage;
                }
            } else {
                // å¦‚æœå¯¹æ‰‹æœ‰æŠ¤ç”²ï¼Œå…ˆæ¶ˆè€—æŠ¤ç”²
                if (gameState.opponentArmor > 0) {
                    if (gameState.opponentArmor >= damage) {
                        gameState.opponentArmor -= damage;
                        logMessage(`å¯¹æ‰‹çš„æŠ¤ç”²å¸æ”¶äº†${damage}ç‚¹ä¼¤å®³ï¼`, 'opponent');
                        damage = 0;
                    } else {
                        const remainingDamage = damage - gameState.opponentArmor;
                        logMessage(`å¯¹æ‰‹çš„æŠ¤ç”²å¸æ”¶äº†${gameState.opponentArmor}ç‚¹ä¼¤å®³ï¼`, 'opponent');
                        gameState.opponentArmor = 0;
                        damage = remainingDamage;
                    }
                }
                
                // å¤„ç†å‰©ä½™ä¼¤å®³
                if (damage > 0) {
                    gameState.opponentHealth -= damage;
                }
            }
            
            checkGameOver();
        }
        
        // æ¢å¤éšä»ç”Ÿå‘½å€¼
        function healMinion(minion, amount) {
            const minionEl = document.querySelector(`.minion[data-id="${minion.uniqueId}"]`);
            if (minionEl) {
                minionEl.classList.add('heal-animation');
                setTimeout(() => {
                    minionEl.classList.remove('heal-animation');
                }, 500);
            }
            
            const oldHealth = minion.health;
            minion.health = Math.min(minion.health + amount, minion.baseHealth);
            const healedAmount = minion.health - oldHealth;
            
            if (healedAmount > 0) {
                logMessage(`${minion.name}æ¢å¤äº†${healedAmount}ç‚¹ç”Ÿå‘½å€¼ï¼`, 'player', 'heal');
            }
        }
        
        // æ¢å¤è‹±é›„ç”Ÿå‘½å€¼
        function healHero(hero, amount) {
            if (hero === 'player') {
                const oldHealth = gameState.playerHealth;
                gameState.playerHealth = Math.min(gameState.playerHealth + amount, gameState.playerMaxHealth);
                const healedAmount = gameState.playerHealth - oldHealth;
                
                // æ·»åŠ è‹±é›„æ²»ç–—åŠ¨ç”»
                const heroEl = document.getElementById('player-portrait');
                heroEl.classList.add('heal-animation');
                setTimeout(() => {
                    heroEl.classList.remove('heal-animation');
                }, 500);
                
                return healedAmount;
            } else {
                const oldHealth = gameState.opponentHealth;
                gameState.opponentHealth = Math.min(gameState.opponentHealth + amount, gameState.opponentMaxHealth);
                const healedAmount = gameState.opponentHealth - oldHealth;
                
                // æ·»åŠ è‹±é›„æ²»ç–—åŠ¨ç”»
                const heroEl = document.getElementById('opponent-portrait');
                heroEl.classList.add('heal-animation');
                setTimeout(() => {
                    heroEl.classList.remove('heal-animation');
                }, 500);
                
                return healedAmount;
            }
        }
        
        // æ¸…ç†æ­»äº¡éšä»
        function cleanupDeadMinions() {
            // æ¸…ç†ç©å®¶æ­»äº¡éšä»
            const deadPlayerMinions = gameState.playerMinions.filter(minion => minion.health <= 0);
            deadPlayerMinions.forEach(minion => {
                gameState.playerGraveyard.push(minion);
            });
            gameState.playerMinions = gameState.playerMinions.filter(minion => minion.health > 0);
            
            // æ¸…ç†å¯¹æ‰‹æ­»äº¡éšä»
            const deadOpponentMinions = gameState.opponentMinions.filter(minion => minion.health <= 0);
            deadOpponentMinions.forEach(minion => {
                gameState.opponentGraveyard.push(minion);
            });
            gameState.opponentMinions = gameState.opponentMinions.filter(minion => minion.health > 0);
            
            // é‡æ–°åº”ç”¨å…‰ç¯æ•ˆæœ
            applyAuraEffects();
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
            checkGameOver();
        }
        
        // é‡ç½®ç›®æ ‡é€‰æ‹©çŠ¶æ€
        function resetTargeting() {
            // ç§»é™¤æ‰€æœ‰å¯é€‰ç›®æ ‡é«˜äº®
            document.querySelectorAll('.can-target').forEach(el => {
                el.classList.remove('can-target');
            });
        }
        
        // æ£€æŸ¥æ˜¯å¦èƒ½é€‰æ‹©è¯¥ç›®æ ‡
        function canTargetMinion(minion, targetType) {
            switch (targetType) {
                case 'any':
                    return true;
                case 'friendly':
                case 'friendly-minion':
                    return gameState.playerMinions.some(m => m.uniqueId === minion.uniqueId);
                case 'enemy':
                case 'enemy-minion':
                    return gameState.opponentMinions.some(m => m.uniqueId === minion.uniqueId);
                default:
                    return false;
            }
        }
        
        // ç»“æŸç©å®¶å›åˆ
        function endPlayerTurn() {
            if (gameState.currentTurn !== 'player' || gameState.gameOver || gameState.spellInProgress) {
                return;
            }
            
            // åº”ç”¨å›åˆç»“æŸæ•ˆæœ
            applyEndTurnEffects('player');
            
            logMessage('å›åˆç»“æŸï¼Œå¯¹æ‰‹å›åˆå¼€å§‹ï¼', 'system');
            gameState.currentTurn = 'opponent';
            
            // æ›´æ–°å›åˆæŒ‡ç¤ºå™¨
            document.getElementById('turn-indicator').textContent = 'å¯¹æ‰‹å›åˆ';
            document.getElementById('turn-indicator').classList.add('enemy-turn');
            
            // æ›´æ–°å½“å‰å›åˆé«˜äº®
            document.getElementById('player-area').classList.remove('current-turn');
            document.getElementById('opponent-area').classList.add('current-turn');
            
            // é‡ç½®ç›®æ ‡é€‰æ‹©
            resetTargeting();
            gameState.selectedCard = null;
            gameState.selectedMinion = null;
            
            // å¯¹æ‰‹å›åˆå¼€å§‹
            startOpponentTurn();
        }
        
        // åº”ç”¨å›åˆç»“æŸæ•ˆæœ
        function applyEndTurnEffects(player) {
            // ç§»é™¤éšä»çš„justPlayedæ ‡è®°
            if (player === 'player') {
                gameState.playerMinions.forEach(minion => {
                    minion.justPlayed = false;
                    
                    // å¤„ç†ç‰¹å®šçš„å›åˆç»“æŸæ•ˆæœ
                    if (minion.effects.includes('endTurn')) {
                        if (minion.endTurnEffect === 'heal') {
                            healHero('player', 2);
                            logMessage(`${minion.name}ä¸ºä½ æ¢å¤äº†2ç‚¹ç”Ÿå‘½å€¼ï¼`, 'player', 'heal');
                        }
                    }
                    
                    // å¤„ç†æˆé•¿æ•ˆæœ
                    if (minion.effects.includes('growing')) {
                        if (minion.growEffect === 'attack+1') {
                            minion.attack += minion.growValue || 1;
                            minion.originalAttack += minion.growValue || 1;
                            logMessage(`${minion.name}çš„æ”»å‡»åŠ›+${minion.growValue || 1}ï¼`, 'player');
                        }
                    }
                });
                
                // ç§»é™¤ä¸´æ—¶æ³•åŠ›æ°´æ™¶
                gameState.playerTempMana = 0;
                
                // ç§»é™¤æ­¦å™¨å…ç–«æ•ˆæœ
                if (gameState.playerImmunity) {
                    gameState.playerImmunity = false;
                    logMessage(`ä½ çš„å…ç–«æ•ˆæœæ¶ˆå¤±äº†ï¼`, 'player');
                }
            } else {
                gameState.opponentMinions.forEach(minion => {
                    minion.justPlayed = false;
                    
                    // å¤„ç†ç‰¹å®šçš„å›åˆç»“æŸæ•ˆæœ
                    if (minion.effects.includes('endTurn')) {
                        if (minion.endTurnEffect === 'heal') {
                            healHero('opponent', 2);
                            logMessage(`${minion.name}ä¸ºå¯¹æ‰‹æ¢å¤äº†2ç‚¹ç”Ÿå‘½å€¼ï¼`, 'opponent', 'heal');
                        }
                    }
                    
                    // å¤„ç†æˆé•¿æ•ˆæœ
                    if (minion.effects.includes('growing')) {
                        if (minion.growEffect === 'attack+1') {
                            minion.attack += minion.growValue || 1;
                            minion.originalAttack += minion.growValue || 1;
                            logMessage(`${minion.name}çš„æ”»å‡»åŠ›+${minion.growValue || 1}ï¼`, 'opponent');
                        }
                    }
                });
                
                // ç§»é™¤ä¸´æ—¶æ³•åŠ›æ°´æ™¶
                gameState.opponentTempMana = 0;
            }
        }
        
        // å¼€å§‹å¯¹æ‰‹å›åˆ
        function startOpponentTurn() {
            // å¢åŠ å¯¹æ‰‹çš„æ³•åŠ›æ°´æ™¶
            gameState.opponentMaxMana = Math.min(10, gameState.opponentMaxMana + 1);
            gameState.opponentMana = gameState.opponentMaxMana;
            
            // å¯¹æ‰‹æŠ½ç‰Œ
            drawCard('opponent');
            
            // é‡ç½®å¯¹æ‰‹éšä»çš„æ”»å‡»çŠ¶æ€
            gameState.opponentMinions.forEach(minion => {
                minion.hasAttacked = false;
            });
            
            // æ›´æ–°UI
            updateUI();
            
            // ç®€å•AIå†³ç­–
            setTimeout(() => {
                opponentAI();
            }, 1000);
        }
        
        // å¯¹æ‰‹AIå†³ç­–
        async function opponentAI() {
            if (gameState.gameOver) {
                return;
            }
            
            // 1. å°è¯•ä½¿ç”¨éšä»ç‰Œ
            await playOpponentMinions();
            
            // 2. å°è¯•ä½¿ç”¨æ³•æœ¯ç‰Œ
            await playOpponentSpells();
            
            // 3. éšä»æ”»å‡»
            await opponentAttack();
            
            // ç»“æŸå¯¹æ‰‹å›åˆ
            setTimeout(() => {
                endOpponentTurn();
            }, 1000);
        }
        
        // å¯¹æ‰‹ä½¿ç”¨éšä»ç‰Œ
        async function playOpponentMinions() {
            // æŒ‰ç…§è´¹ç”¨ä»é«˜åˆ°ä½æ’åºï¼Œä¼˜å…ˆä½¿ç”¨é«˜è´¹éšä»
            const playableMinions = gameState.opponentHand
                .filter(card => card.type === 'minion' && (card.currentCost || card.cost) <= gameState.opponentMana)
                .sort((a, b) => (b.currentCost || b.cost) - (a.currentCost || a.cost));
            
            for (const card of playableMinions) {
                if (gameState.opponentMinions.length < 7 && (card.currentCost || card.cost) <= gameState.opponentMana) {
                    // ä½¿ç”¨éšä»ç‰Œ
                    gameState.opponentMana -= (card.currentCost || card.cost);
                    
                    // ä»æ‰‹ç‰Œä¸­ç§»é™¤
                    gameState.opponentHand = gameState.opponentHand.filter(c => c.uniqueId !== card.uniqueId);
                    
                    // åˆ›å»ºéšä»å¯¹è±¡
                    const minion = {
                        ...card,
                        hasAttacked: !card.effects.includes('charge'),
                        justPlayed: true,
                        originalAttack: card.attack,
                        originalHealth: card.health,
                        baseHealth: card.baseHealth || card.health,
                        side: 'opponent'
                    };
                    
                    // æ·»åŠ åˆ°åœºä¸Š
                    gameState.opponentMinions.push(minion);
                    
                    logMessage(`å¯¹æ‰‹ä½¿ç”¨äº†${card.name}ï¼`, 'opponent');
                    
                    // æ·»åŠ éšä»å…¥åœºåŠ¨ç”»
                    setTimeout(() => {
                        const minionElement = document.querySelector(`.minion[data-id="${minion.uniqueId}"]`);
                        if (minionElement) {
                            minionElement.classList.add('card-being-played');
                            setTimeout(() => {
                                minionElement.classList.remove('card-being-played');
                            }, 500);
                        }
                    }, 100);
                    
                    // å¤„ç†æˆ˜å¼æ•ˆæœ
                    if (minion.battlecry) {
                        handleOpponentBattlecry(minion);
                    }
                    
                    // åº”ç”¨å…‰ç¯æ•ˆæœ
                    applyAuraEffects();
                    
                    // æ›´æ–°UI
                    updateUI();
                    
                    // ç­‰å¾…ä¸€ç‚¹æ—¶é—´
                    await sleep(700);
                }
            }
        }
        
        // å¤„ç†å¯¹æ‰‹æˆ˜å¼æ•ˆæœ
        function handleOpponentBattlecry(minion) {
            switch (minion.battlecry) {
                case 'draw':
                    drawCard('opponent');
                    break;
                case 'damage-all-enemy-minions':
                    // å¯¹æ‰€æœ‰ç©å®¶éšä»é€ æˆ1ç‚¹ä¼¤å®³
                    gameState.playerMinions.forEach(m => {
                        damageMinion(m, 1, 'player');
                    });
                    cleanupDeadMinions();
                    break;
                case 'damage-all-minions':
                    // å¯¹æ‰€æœ‰éšä»é€ æˆä¼¤å®³
                    gameState.playerMinions.forEach(m => {
                        damageMinion(m, 1, 'player');
                    });
                    gameState.opponentMinions.forEach(m => {
                        if (m.uniqueId !== minion.uniqueId) {
                            damageMinion(m, 1, 'opponent');
                        }
                    });
                    cleanupDeadMinions();
                    break;
                case 'gain-health':
                    // å¢åŠ ç”Ÿå‘½å€¼
                    minion.health += 1;
                    minion.baseHealth += 1;
                    logMessage(`${minion.name}è·å¾—äº†+1ç”Ÿå‘½å€¼ï¼`, 'opponent');
                    break;
            }
        }
        
        // å¯¹æ‰‹ä½¿ç”¨æ³•æœ¯ç‰Œ
        async function playOpponentSpells() {
            const playableSpells = gameState.opponentHand
                .filter(card => card.type === 'spell' && card.cost <= gameState.opponentMana)
                .sort((a, b) => b.cost - a.cost);
            
            for (const spell of playableSpells) {
                if (spell.cost <= gameState.opponentMana) {
                    let shouldUseSpell = false;
                    let target = null;
                    
                    // å†³å®šæ˜¯å¦ä½¿ç”¨æ³•æœ¯ä»¥åŠç›®æ ‡
                    switch (spell.effect) {
                        case 'damage':
                            // ä¼˜å…ˆæ”»å‡»ç©å®¶éšä»ï¼Œå¦‚æœæ²¡æœ‰åˆ™æ”»å‡»ç©å®¶è‹±é›„
                            if (gameState.playerMinions.length > 0) {
                                // é€‰æ‹©è¡€é‡æœ€ä½çš„éšä»
                                const lowestHealthMinion = gameState.playerMinions.sort((a, b) => a.health - b.health)[0];
                                target = lowestHealthMinion;
                            } else {
                                target = 'player';
                            }
                            shouldUseSpell = true;
                            break;
                        case 'heal':
                        case 'heal-and-mana':
                            // ä¼˜å…ˆæ²»ç–—è¡€é‡ä½çš„éšä»æˆ–è‡ªå·±
                            if (gameState.opponentHealth < 15) {
                                target = 'opponent';
                                shouldUseSpell = true;
                            } else if (gameState.opponentMinions.some(m => m.health < m.baseHealth)) {
                                // é€‰æ‹©è¡€é‡æŸå¤±æœ€å¤šçš„éšä»
                                const minionsWithDamage = gameState.opponentMinions.filter(m => m.health < m.baseHealth);
                                if (minionsWithDamage.length > 0) {
                                    target = minionsWithDamage.sort((a, b) => (a.baseHealth - a.health) - (b.baseHealth - b.health))[0];
                                    shouldUseSpell = true;
                                }
                            }
                            break;
                        case 'aoe-damage':
                        case 'fan-of-knives':
                            // å¦‚æœç©å®¶æœ‰è‡³å°‘2ä¸ªéšä»ï¼Œä½¿ç”¨ç¾¤ä½“ä¼¤å®³
                            shouldUseSpell = gameState.playerMinions.length >= 2;
                            break;
                        case 'draw':
                            // æ€»æ˜¯å°è¯•æŠ½ç‰Œ
                            shouldUseSpell = true;
                            break;
                        case 'destroy':
                            // ä¼˜å…ˆæ¶ˆç­ç©å®¶æœ€å¼ºçš„éšä»
                            if (gameState.playerMinions.length > 0) {
                                // é€‰æ‹©æ”»å‡»åŠ›æœ€é«˜çš„éšä»
                                const strongestMinion = gameState.playerMinions.sort((a, b) => b.attack - a.attack)[0];
                                target = strongestMinion;
                                shouldUseSpell = true;
                            }
                            break;
                        case 'buff-attack':
                            // ç»™æ”»å‡»åŠ›æœ€é«˜çš„éšä»buff
                            if (gameState.opponentMinions.length > 0) {
                                const strongestMinion = gameState.opponentMinions.sort((a, b) => b.attack - a.attack)[0];
                                target = strongestMinion;
                                shouldUseSpell = true;
                            }
                            break;
                        case 'holy-nova':
                        case 'flamestrike':
                            // å¦‚æœç©å®¶æœ‰è‡³å°‘2ä¸ªéšä»ï¼Œä½¿ç”¨ç¾¤ä½“ä¼¤å®³
                            shouldUseSpell = gameState.playerMinions.length >= 2;
                            break;
                        case 'return-minions':
                            // å¦‚æœç©å®¶æœ‰è‡³å°‘3ä¸ªéšä»ï¼Œä½¿ç”¨ææƒ§å’†å“®
                            shouldUseSpell = gameState.playerMinions.length >= 3;
                            break;
                    }
                    
                    if (shouldUseSpell) {
                        // ä½¿ç”¨æ³•æœ¯
                        useOpponentSpell(spell, target);
                        
                        // ç­‰å¾…ä¸€ç‚¹æ—¶é—´
                        await sleep(700);
                    }
                }
            }
        }
        
        // å¯¹æ‰‹ä½¿ç”¨æ³•æœ¯
        function useOpponentSpell(spell, target = null) {
            // æ‰£é™¤æ³•åŠ›å€¼
            gameState.opponentMana -= spell.cost;
            
            // ä»æ‰‹ç‰Œä¸­ç§»é™¤
            gameState.opponentHand = gameState.opponentHand.filter(c => c.uniqueId !== spell.uniqueId);
            
            logMessage(`å¯¹æ‰‹ä½¿ç”¨äº†${spell.name}ï¼`, 'opponent');
            
            // è®¡ç®—æ³•æœ¯ä¼¤å®³åŠ æˆ
            let spellDamageBonus = calculateSpellDamage('opponent');
            
            // å¤„ç†æ³•æœ¯æ•ˆæœ
            switch (spell.effect) {
                case 'damage':
                    // å¯¹å•ä¸ªç›®æ ‡é€ æˆä¼¤å®³
                    if (target) {
                        const totalDamage = spell.value + spellDamageBonus;
                        if (target.type === 'minion') {
                            damageMinion(target, totalDamage, 'player');
                        } else if (target === 'player') {
                            dealDamageToHero('player', totalDamage);
                            animateHeroDamage('player');
                            logMessage(`ä½ å—åˆ°${totalDamage}ç‚¹ä¼¤å®³ï¼`, 'player', 'damage');
                        } else if (target === 'opponent') {
                            dealDamageToHero('opponent', totalDamage);
                            animateHeroDamage('opponent');
                            logMessage(`å¯¹æ‰‹å—åˆ°${totalDamage}ç‚¹ä¼¤å®³ï¼`, 'opponent', 'damage');
                        }
                    }
                    break;
                case 'heal':
                    // æ¢å¤ç”Ÿå‘½å€¼
                    if (target) {
                        if (target.type === 'minion') {
                            healMinion(target, spell.value);
                        } else if (target === 'opponent') {
                            healHero('opponent', spell.value);
                            logMessage(`å¯¹æ‰‹æ¢å¤äº†${spell.value}ç‚¹ç”Ÿå‘½å€¼ï¼`, 'opponent', 'heal');
                        }
                    }
                    break;
                case 'heal-and-mana':
                    // æ¢å¤ç”Ÿå‘½å€¼å¹¶è·å¾—ä¸´æ—¶æ³•åŠ›æ°´æ™¶
                    if (target) {
                        if (target.type === 'minion') {
                            healMinion(target, spell.value);
                        } else if (target === 'opponent') {
                            healHero('opponent', spell.value);
                            gameState.opponentTempMana += 1;
                            gameState.opponentMana += 1;
                            logMessage(`å¯¹æ‰‹æ¢å¤äº†${spell.value}ç‚¹ç”Ÿå‘½å€¼ï¼Œå¹¶è·å¾—ä¸€ä¸ªä¸´æ—¶æ³•åŠ›æ°´æ™¶ï¼`, 'opponent', 'heal');
                        }
                    }
                    break;
                case 'aoe-damage':
                    // å¯¹æ‰€æœ‰ç©å®¶éšä»é€ æˆä¼¤å®³
                    const aoeDamage = spell.value + spellDamageBonus;
                    gameState.playerMinions.forEach(minion => {
                        damageMinion(minion, aoeDamage, 'player');
                    });
                    break;
                case 'draw':
                    // æŠ½ç‰Œ
                    for (let i = 0; i < spell.value; i++) {
                        drawCard('opponent');
                    }
                    break;
                case 'fan-of-knives':
                    // åˆ€æ‰‡ï¼šä¼¤å®³ + æŠ½ç‰Œ
                    const fanDamage = spell.value + spellDamageBonus;
                    gameState.playerMinions.forEach(minion => {
                        damageMinion(minion, fanDamage, 'player');
                    });
                    drawCard('opponent');
                    break;
                case 'destroy':
                    // æ¶ˆç­éšä»
                    if (target && target.type === 'minion') {
                        destroyMinion(target, 'player');
                        logMessage(`${target.name}è¢«æ¶ˆç­äº†ï¼`, 'opponent');
                    }
                    break;
                case 'buff-attack':
                    // æé«˜æ”»å‡»åŠ›
                    if (target && target.type === 'minion') {
                        target.attack += spell.value;
                        target.originalAttack += spell.value;
                        logMessage(`${target.name}è·å¾—äº†+${spell.value}æ”»å‡»åŠ›ï¼`, 'opponent');
                    }
                    break;
                case 'holy-nova':
                    // ç¥åœ£æ–°æ˜Ÿï¼šå¯¹æ•Œæ–¹éšä»é€ æˆä¼¤å®³ï¼Œä¸ºå‹æ–¹è§’è‰²æ¢å¤ç”Ÿå‘½å€¼
                    const novaDamage = spell.value + spellDamageBonus;
                    gameState.playerMinions.forEach(minion => {
                        damageMinion(minion, novaDamage, 'player');
                    });
                    
                    // æ¢å¤å‹æ–¹è§’è‰²ç”Ÿå‘½å€¼
                    healHero('opponent', spell.value);
                    gameState.opponentMinions.forEach(minion => {
                        healMinion(minion, spell.value);
                    });
                    logMessage(`å¯¹æ‰‹çš„æ‰€æœ‰è§’è‰²æ¢å¤äº†${spell.value}ç‚¹ç”Ÿå‘½å€¼ï¼`, 'opponent', 'heal');
                    break;
                case 'flamestrike':
                    // çƒˆç„°é£æš´ï¼šå¯¹æ‰€æœ‰æ•Œæ–¹è§’è‰²é€ æˆä¼¤å®³
                    const flamestrikeDamage = spell.value + spellDamageBonus;
                    gameState.playerMinions.forEach(minion => {
                        damageMinion(minion, flamestrikeDamage, 'player');
                    });
                    dealDamageToHero('player', flamestrikeDamage);
                    animateHeroDamage('player');
                    logMessage(`ä½ å—åˆ°${flamestrikeDamage}ç‚¹ä¼¤å®³ï¼`, 'player', 'damage');
                    break;
                case 'return-minions':
                    // ææƒ§å’†å“®ï¼šå°†æ‰€æœ‰æ•Œæ–¹éšä»ç§»å›æ‰‹ç‰Œ
                    gameState.playerMinions.forEach(minion => {
                        if (gameState.playerHand.length < 10) {
                            gameState.playerHand.push({...minion, uniqueId: Date.now() + Math.random().toString(36).substr(2, 9)});
                        }
                    });
                    gameState.playerMinions = [];
                    logMessage(`æ‰€æœ‰ä½ çš„éšä»å›åˆ°äº†æ‰‹ç‰Œï¼`, 'opponent');
                    break;
            }
            
// æ¸…ç†æ­»äº¡éšä»
            cleanupDeadMinions();
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
            checkGameOver();
            
            // æ›´æ–°UI
            updateUI();
        }
        
        // å¯¹æ‰‹éšä»æ”»å‡»
        async function opponentAttack() {
            // è·å–å¯ä»¥æ”»å‡»çš„éšä»
            const attackers = gameState.opponentMinions.filter(minion => !minion.hasAttacked && !minion.justPlayed);
            
            for (const attacker of attackers) {
                let target = null;
                
                // å¦‚æœç©å®¶æœ‰å˜²è®½éšä»ï¼Œå¿…é¡»å…ˆæ”»å‡»å˜²è®½éšä»
                const tauntMinions = gameState.playerMinions.filter(minion => minion.effects.includes('taunt'));
                
                if (tauntMinions.length > 0) {
                    // é€‰æ‹©ç”Ÿå‘½å€¼æœ€ä½çš„å˜²è®½éšä»
                    target = tauntMinions.sort((a, b) => a.health - b.health)[0];
                } else if (gameState.playerMinions.length > 0) {
                    // åŸºæœ¬ç­–ç•¥ï¼šä¼˜å…ˆè§£åœº
                    // 1. å…ˆæŸ¥çœ‹æ˜¯å¦å¯ä»¥å‡»æ€æŸä¸ªéšä»è€Œä¸æŸå¤±è‡ªå·±çš„éšä»
                    let bestTarget = null;
                    let bestValue = -1000;
                    
                    for (const playerMinion of gameState.playerMinions) {
                        // å¦‚æœå¯ä»¥å‡»æ€è¯¥éšä»ä¸”è‡ªå·±å­˜æ´»ï¼Œè¿™æ˜¯æœ€ä¼˜å…ˆçš„
                        if (attacker.attack >= playerMinion.health && playerMinion.attack < attacker.health) {
                            const value = playerMinion.attack * 3 + playerMinion.health * 2;
                            if (value > bestValue) {
                                bestValue = value;
                                bestTarget = playerMinion;
                            }
                        }
                    }
                    
                    // å¦‚æœæ²¡æ‰¾åˆ°æœ€ä½³ç›®æ ‡ï¼Œåˆ™è€ƒè™‘ä»·å€¼äº¤æ¢
                    if (!bestTarget) {
                        for (const playerMinion of gameState.playerMinions) {
                            // è®¡ç®—äº¤æ¢çš„ä»·å€¼ï¼Œå°½é‡ç”¨å°éšä»æ¢å¤§éšä»
                            const tradeValue = (playerMinion.attack * 2 + playerMinion.health) - (attacker.attack + attacker.health);
                            if (tradeValue > bestValue) {
                                bestValue = tradeValue;
                                bestTarget = playerMinion;
                            }
                        }
                    }
                    
                    // å¦‚æœæ‰¾åˆ°ç›®æ ‡ï¼Œè®¾ç½®ä¸ºæ”»å‡»ç›®æ ‡
                    if (bestTarget) {
                        target = bestTarget;
                    } else {
                        // é»˜è®¤æ”»å‡»æœ€å¼±çš„éšä»
                        target = gameState.playerMinions.sort((a, b) => a.health - b.health)[0];
                    }
                } else {
                    // ç›´æ¥æ”»å‡»ç©å®¶è‹±é›„
                    if (!attacker.effects.includes('cant-attack-hero')) {
                        dealDamageToHero('player', attacker.attack);
                        animateHeroDamage('player');
                        logMessage(`${attacker.name}æ”»å‡»äº†ä½ ï¼Œé€ æˆ${attacker.attack}ç‚¹ä¼¤å®³ï¼`, 'opponent', 'damage');
                        attacker.hasAttacked = true;
                        
                        // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                        if (checkGameOver()) {
                            break;
                        }
                        
                        // æ›´æ–°UI
                        updateUI();
                        
                        // ç­‰å¾…ä¸€ç‚¹æ—¶é—´
                        await sleep(700);
                        continue;
                    } else {
                        // éšä»ä¸èƒ½æ”»å‡»è‹±é›„
                        attacker.hasAttacked = true;
                        continue;
                    }
                }
                
                // æ”»å‡»ç›®æ ‡éšä»
                logMessage(`${attacker.name}æ”»å‡»äº†${target.name}ï¼`, 'opponent');
                
                // å¤„ç†åœ£ç›¾
                if (target.effects.includes('divine-shield')) {
                    target.effects = target.effects.filter(e => e !== 'divine-shield');
                    logMessage(`${target.name}çš„åœ£ç›¾è¢«å‡»ç ´äº†ï¼`, 'player');
                } else {
                    damageMinion(target, attacker.attack, 'player');
                }
                
                if (attacker.effects.includes('divine-shield')) {
                    attacker.effects = attacker.effects.filter(e => e !== 'divine-shield');
                    logMessage(`${attacker.name}çš„åœ£ç›¾è¢«å‡»ç ´äº†ï¼`, 'opponent');
                } else {
                    damageMinion(attacker, target.attack, 'opponent');
                }
                
                // å¤„ç†å‰§æ¯’æ•ˆæœ
                if (attacker.effects.includes('poisonous') && !target.effects.includes('divine-shield') && target.health > 0) {
                    destroyMinion(target, 'player');
                    logMessage(`${target.name}è¢«æ¯’æ­»äº†ï¼`, 'opponent');
                }
                
                if (target.effects.includes('poisonous') && !attacker.effects.includes('divine-shield') && attacker.health > 0) {
                    destroyMinion(attacker, 'opponent');
                    logMessage(`${attacker.name}è¢«æ¯’æ­»äº†ï¼`, 'player');
                }
                
                // æ ‡è®°éšä»å·²æ”»å‡»
                attacker.hasAttacked = true;
                
                // æ¸…ç†æ­»äº¡éšä»
                cleanupDeadMinions();
                
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (checkGameOver()) {
                    break;
                }
                
                // æ›´æ–°UI
                updateUI();
                
                // ç­‰å¾…ä¸€ç‚¹æ—¶é—´
                await sleep(700);
            }
        }
        
        // ç»“æŸå¯¹æ‰‹å›åˆ
        function endOpponentTurn() {
            if (gameState.gameOver) {
                return;
            }
            
            // åº”ç”¨å›åˆç»“æŸæ•ˆæœ
            applyEndTurnEffects('opponent');
            
            // å¢åŠ å›åˆè®¡æ•°
            gameState.turnCount++;
            
            logMessage('å¯¹æ‰‹å›åˆç»“æŸï¼Œä½ çš„å›åˆå¼€å§‹ï¼', 'system');
            gameState.currentTurn = 'player';
            
            // æ›´æ–°å›åˆæŒ‡ç¤ºå™¨
            document.getElementById('turn-indicator').textContent = 'ä½ çš„å›åˆ';
            document.getElementById('turn-indicator').classList.remove('enemy-turn');
            
            // æ›´æ–°å½“å‰å›åˆé«˜äº®
            document.getElementById('player-area').classList.add('current-turn');
            document.getElementById('opponent-area').classList.remove('current-turn');
            
            // å¼€å§‹ç©å®¶å›åˆ
            startPlayerTurn();
        }
        
        // å¼€å§‹ç©å®¶å›åˆ
        function startPlayerTurn() {
            // å¢åŠ ç©å®¶çš„æ³•åŠ›æ°´æ™¶
            gameState.playerMaxMana = Math.min(10, gameState.playerMaxMana + 1);
            gameState.playerMana = gameState.playerMaxMana;
            
            // ç©å®¶æŠ½ç‰Œ
            drawCard('player');
            
            // é‡ç½®ç©å®¶éšä»çš„æ”»å‡»çŠ¶æ€
            gameState.playerMinions.forEach(minion => {
                minion.hasAttacked = false;
                minion.justPlayed = false;
            });
            
            // æ›´æ–°å¡ç‰Œè´¹ç”¨ï¼ˆå¦‚å±±å²­å·¨äººç­‰ï¼‰
            gameState.playerHand.forEach(card => {
                if (card.effects && card.effects.includes('cost-reduction')) {
                    if (card.costReduction === 'health-lost') {
                        const healthLost = gameState.playerMaxHealth - gameState.playerHealth;
                        card.currentCost = Math.max(0, card.cost - healthLost);
                    }
                }
            });
            
            // æ›´æ–°UI
            updateUI();
        }
        
        // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
        function checkGameOver() {
            if (gameState.playerHealth <= 0) {
                gameState.gameOver = true;
                document.getElementById('winner-text').textContent = 'ä½ è¾“äº†ï¼';
                document.getElementById('game-over').style.display = 'flex';
                return true;
            } else if (gameState.opponentHealth <= 0) {
                gameState.gameOver = true;
                document.getElementById('winner-text').textContent = 'ä½ èµ¢äº†ï¼';
                document.getElementById('game-over').style.display = 'flex';
                return true;
            }
            
            return false;
        }
        
        // è®°å½•æ¸¸æˆæ—¥å¿—
        function logMessage(message, source = 'system', type = '') {
            const logContainer = document.getElementById('log-container');
            const logMessage = document.createElement('div');
            logMessage.className = `log-message ${source} ${type}`;
            logMessage.textContent = message;
            logContainer.appendChild(logMessage);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // å·¥å…·å‡½æ•° - sleep
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // äº‹ä»¶ç›‘å¬
        document.getElementById('end-turn-btn').addEventListener('click', endPlayerTurn);
        document.getElementById('restart-btn').addEventListener('click', () => {
            document.getElementById('game-over').style.display = 'none';
            initGame();
        });
        
        // æ·»åŠ è‹±é›„ç‚¹å‡»äº‹ä»¶
        document.getElementById('player-portrait').addEventListener('click', () => {
            if (gameState.selectedCard && gameState.selectedCard.type === 'spell') {
                const spell = gameState.selectedCard;
                if (spell.targetType === 'friendly' || spell.targetType === 'friendly-hero' || spell.targetType === 'any') {
                    useSpell(spell, 'player');
                }
            }
        });
        
        document.getElementById('opponent-portrait').addEventListener('click', () => {
            if (gameState.currentTurn === 'player' && !gameState.gameOver) {
                if (gameState.selectedCard && gameState.selectedCard.type === 'spell') {
                    const spell = gameState.selectedCard;
                    if (spell.targetType === 'enemy' || spell.targetType === 'enemy-hero' || spell.targetType === 'any') {
                        useSpell(spell, 'opponent');
                    }
                } else if (gameState.selectedMinion && !gameState.selectedMinion.effects.includes('cant-attack-hero')) {
                    // æ£€æŸ¥å˜²è®½
                    const hasTaunt = gameState.opponentMinions.some(m => m.effects.includes('taunt'));
                    if (hasTaunt) {
                        logMessage(`ä½ å¿…é¡»å…ˆæ”»å‡»å…·æœ‰å˜²è®½çš„éšä»ï¼`, 'player');
                        resetTargeting();
                        gameState.selectedMinion = null;
                        return;
                    }
                    
                    attackMinion(gameState.selectedMinion, 'opponent');
                }
            }
        });
        
        // æ¸¸æˆåˆå§‹åŒ–
        initGame();
    </script>
</body>
</html>
